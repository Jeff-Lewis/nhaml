<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.Core</name></assembly>
<members>
<member name="P:Microsoft.FSharp.Collections.List`1.Tail">
<summary>
 The module 'List' contains additional values and functions related to this type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.List`1.Length">
<summary>
 The module 'List' contains additional values and functions related to this type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.List`1.Item(System.Int32)">
<summary>
 Get the element of the list at the given position. Note lists are represented
 as linked lists so this is an O(n) operation.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.List`1.IsEmpty">
<summary>
 The module 'List' contains additional values and functions related to this type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.List`1.Head">
<summary>
 The module 'List' contains additional values and functions related to this type,
 e.g. List.fold_left, List.append etc.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.List`1.Empty">
<summary>
 The module 'List' contains additional values and functions related to this type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List`1.Cons(``0,Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 The module 'List' contains additional values and functions related to this type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.List`1">
 <summary>
 The type of immutable singly-linked lists.  

 Use the constructors <c>[]</c> and <c>::</c> (infix) to create values of this type, or
 the notation <c>[1;2;3]</c>.   Use the values in the <c>List</c> module to manipulate 
 values of this type, or pattern match against the values directly.
 </summary>

</member>
<member name="P:Microsoft.FSharp.Collections.Map`2.Item(``0)">
<summary>
 Lookup an element in the map. Raise <c>KeyNotFoundException</c> if no binding
 exists in the map.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Map`2.IsEmpty">
<summary>
 Return true if there are no bindings in the map.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Map`2.Count">
<summary>
 The number of bindings in the map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.TryFind(``0)">
<summary>
 Lookup an element in the map, returning a <c>Some</c> value if the element is in the domain 
 of the map and <c>None</c> if not.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.ToList">
<summary>
 The elements of the set as a list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.ToArray">
<summary>
 The elements of the set as an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Remove(``0)">
<summary>
 Remove an element from the domain of the map.  No exception is raised if the element is not present.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Partition(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}})">
<summary>
 Build two new maps, one containing the bindings for which the given predicate returns 'true',
 and the other the remaining bindings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.MapRange``1(Microsoft.FSharp.Core.FastFunc`2{``1,``2})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Map``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The index passed to the
 function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Iterate(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}})">
<summary>
 Apply the given function to each binding in the dictionary
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.FromList(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Builds a map that contains all the elements of the list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.ForAll(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}})">
<summary>
 Return true if the given predicate returns true for all of the
 bindings in the map. Always returns true if the map is empty.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.FoldSection``1(``0)">
<summary>
 Given the start and end points of a key range,
 Fold over the bindings in the map that are in the range,
 and the end points are included if present (the range is considered a closed interval).
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Fold``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``2}}})">
<summary>
 Fold over the bindings in the map.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.First``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Option`1{``2}}})">
<summary>
 Search the map looking for the first element where the given function returns a <c>Some</c> value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Filter(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}})">
<summary>
 Build a new map containing the bindings for which the given predicate returns 'true'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Exists(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}})">
<summary>
 Return true if the given predicate returns true for one of the
 bindings in the map. Always returns false if the map is empty.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Empty">
<summary>
 The empty map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Create">

</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Create(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Build a map that contains the bindings of the given IEnumerable
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.ContainsKey(``0)">
<summary>
 Test is an element is in the domain of the map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Add(``0,``1)">
<summary>
 Return a new map with the binding added to the given map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2..ctor(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Build a map that contains the bindings of the given IEnumerable
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Map`2">
<summary>
 Immutable maps.  Keys are ordered by F# generic comparison.

 <performance> 
   Maps based on generic comparison are efficient for small keys. They are not a suitable choice if keys are recursive data structures 
   or if keys require bespoke comparison semantics.
 </performance>
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ResizeArray`1">

</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.op_Subtraction(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.op_Addition(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Compute the union of the two sets.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Set`1.MinimumElement">
<summary>
 Returns the lowest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Set`1.MaximumElement">
<summary>
 Returns the highest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Set`1.IsEmpty">
<summary>
 A useful shortcut for Set.is_empty.  See the Set module for further operations on sets.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Set`1.Count">
<summary>
 The number of elements in the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Set`1.Choose">
<summary>
 Returns the lowest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Union(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Compute the union of the two sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Union(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Collections.Set`1{``0}})">
<summary>
 Compute the union of multiple sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.ToList">
<summary>
 The elements of the set as a list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.ToArray">
<summary>
 The elements of the set as an array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Singleton(``0)">
<summary>
 A singleton set based on the default structural comparison operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Remove(``0)">
<summary>
 A useful shortcut for Set.remove.  Note this operation produces a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Partition(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean})">
<summary>
 Build two new sets, one containing the elements for which the given predicate returns 'true',
 and the other the remaining elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Map``1(Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 Return a new collection containing the results of applying the
 given function to each element of the input set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Iterate(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit})">
<summary>
 Apply the given function to each binding in the collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.IsSupersetOf(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Evaluates to "true" if all elements of the first set are in the second
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.IsSubsetOf(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Evaluates to "true" if all elements of the second set are in the first
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Intersection(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Compute the intersection of the two sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Intersection(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Collections.Set`1{``0}})">
<summary>
 Compute the intersection of N sets. At least one set must be given.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.GetPreviousElement(``0)">
<summary>
 Returns the greatest element in the set that is less than the given key 
 according to the ordering being used for the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.GetNextElement(``0)">
<summary>
 Returns the least element in the set that is greater than the given key 
 according to the ordering being used for the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.FromArray(``0[]`1)">
<summary>
 Build a set that contains the same elements as the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.ForAll(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean})">
<summary>
 Test if all elements of the collection satisfy the given predicate.
 If the elements are <c>i0...iN</c> and "j0...jN" then computes 
 "p i0 &amp;&amp; ... &amp;&amp; p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Fold``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}})">
<summary>
 Apply the given accumulating function to all the elements of the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Filter(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean})">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns "true"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Exists(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean})">
<summary>
 Test if any element of the collection satisfies the given predicate.
 If the elements are <c>i0...iN</c> then computes "p i0 or ... or p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Equality(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Compares two sets and returns true if they are equal or false otherwise
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Empty">
<summary>
 The empty set based on the default structural comparison operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Difference(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Create(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build a set that contains the same elements as the given IEnumerable
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Contains(``0)">
<summary>
 A useful shortcut for Set.mem.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Compare(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Compares a and b and returns 1 if a &gt; b, -1 if b &lt; a and 0 if a = b
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Add(``0)">
<summary>
 A useful shortcut for Set.add.  Note this operation produces a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1..ctor(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Create a set containing elements drawn from the given sequence.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Set`1">
<summary>
 Immutable sets based on binary trees, where comparison is the
 F# structural comparison function, potentially using implementations
 of the IComparable interface on key values.

 See the Set module for further operations on sets.

 These sets can be used with elements of any type, but you should check that
 structural hashing and equality on the element type are correct for your type.  
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.list`1">
 <summary>
 The type of immutable singly-linked lists.  

 Use the constructors <c>[]</c> and <c>::</c> (infix) to create values of this type, or
 the notation <c>[1;2;3]</c>.   Use the values in the <c>List</c> module to manipulate 
 values of this type, or pattern match against the values directly.
 </summary>

</member>
<member name="T:Microsoft.FSharp.Collections.seq`1">

</member>
<member name="M:Microsoft.FSharp.Collections.Array2.base1``1(``0[,]`1)">
<summary>
 Fetch the base-index for the first dimension of the array.

 See notes on the Array2 module re. zero-basing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.base2``1(``0[,]`1)">
<summary>
 Fetch the base-index for the second dimension of the array.

 See notes on the Array2 module re. zero-basing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.blit``1(``0[,]`1,System.Int32,System.Int32,``0[,]`1,System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.copy``1(``0[,]`1)">
<summary>
 Build a new array whose elements are the same as the input array.

 For non-zero-based arrays the basing on an input array will be propogated to the output
 array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.create``1(System.Int32,System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.create_based``1(System.Int32,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 Create an array where the entries are initially the
 a "default" value. For .NET reference types this will
 be "null".  For other types behaviour is undefined if 
 you access an entry of the array before setting it.

 See notes on the Array2 module re. zero-basing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.get``1(``0[,]`1,System.Int32,System.Int32)">
<summary>
 Fetch an element from a 2D array.  You can also use the syntax 'arr.[idx1,idx2]'
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.init``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}})">
<summary>
 Create an array given the dimensions and a generator function to compute the elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.init_based``1(System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}})">
<summary>
 Initialize a non-zero-based 2D array.

 See notes on the Array2 module re. zero-basing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[,]`1)">
<summary>
 Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}}},``0[,]`1)">
<summary>
 Apply the given function to each element of the array.  The integer indicies passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.length1``1(``0[,]`1)">
<summary>
 Return the length of an array in the first dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.length2``1(``0[,]`1)">
<summary>
 Return the length of an array in the second dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.make``1(System.Int32,System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array2.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[,]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array.

 For non-zero-based arrays the basing on an input array will be propogated to the output
 array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}}},``0[,]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer indices passed to the
 function indicates the element being transformed.

 For non-zero-based arrays the basing on an input array will be propogated to the output
 array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.rebase``1(``0[,]`1)">
<summary>
 Build a new array whose elements are the same as the input array but
 where a non-zero-based input array generates a corresponding zero-based 
 output array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.set``1(``0[,]`1,System.Int32,System.Int32,``0)">
<summary>
 Set the value of an element in an array.  You can also 
 use the syntax 'arr.[idx1,idx2] &lt;- e'
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.sub``1(``0[,]`1,System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Build a new array that contains the given subrange specified by
 starting index and length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.zero_create``1(System.Int32,System.Int32)">
<summary>
 Create an array where the entries are initially the
 a "default" value. For .NET reference types this will
 be "null".  For other types behaviour is undefined if 
 you access an entry of the array before setting it.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Array2">
<summary>
 Basic operations on 2-dimensional arrays. 

 F# and .NET multi-dimensional arrays are typically zero-based. 
 However, .NET multi-dimensional arrays used in conjunction with external
 libraries (e.g. libraries associated with Visual Basic) be 
 non-zero based, using a potentially different base for each dimension.
 The operations in this module will accept such arrays, and
 the basing on an input array will be propogated to a matching output
 array on the <c>Array2.map</c> and <c>Array2.mapi</c> operations.
 Non-zero-based arrays can also be created using <c>Array2.zero_create_based</c>, 
 <c>Array2.create_based</c> and <c>Array2.init_based</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3.create``1(System.Int32,System.Int32,System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3.get``1(``0[,,]`1,System.Int32,System.Int32,System.Int32)">
<summary>
 Fetch an element from a 3D array.  You can also use the syntax 'arr.[idx1,idx2,idx3]'
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3.init``1(System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}}})">
<summary>
 Create an array given the dimensions and a generator function to compute the elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[,,]`1)">
<summary>
 Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}}}},``0[,,]`1)">
<summary>
 Apply the given function to each element of the array.  The integer indicies passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3.length1``1(``0[,,]`1)">
<summary>
 Return the length of an array in the first dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3.length2``1(``0[,,]`1)">
<summary>
 Return the length of an array in the second dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3.length3``1(``0[,,]`1)">
<summary>
 Return the length of an array in the third dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3.make``1(System.Int32,System.Int32,System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array3.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[,,]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array.

 For non-zero-based arrays the basing on an input array will be propogated to the output
 array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}}}},``0[,,]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer indices passed to the
 function indicates the element being transformed.

 For non-zero-based arrays the basing on an input array will be propogated to the output
 array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3.set``1(``0[,,]`1,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 Set the value of an element in an array.  You can also 
 use the syntax 'arr.[idx1,idx2,idx3] &lt;- e'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3.zero_create``1(System.Int32,System.Int32,System.Int32)">
<summary>
 Create an array where the entries are initially the
 a "default" value. For .NET reference types this will
 be "null".  For other types behaviour is undefined if 
 you access an entry of the array before setting it.

 See notes on the Array3 module re. zero-basing.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Array3">
<summary>
 Basic operations on 3-dimensional arrays.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.append``1(``0[]`1,``0[]`1)">
<summary>
 Build a new array that contains the elements of the first array followed by the elements of the second array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.average``1(``0[]`1)">
<summary>
 Return the average of the elements in the array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.average_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">
<summary>
 Return the average of the elements generated by applying the function to each element of the array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.blit``1(``0[]`1,System.Int32,``0[]`1,System.Int32,System.Int32)">
<summary>
 Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.choose``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},``0[]`1)">
<summary>
 Apply the given function to each element of the array. Return
 the array comprised of the results "x" for each element where
 the function returns Some(x)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.combine``2(``0[]`1,``1[]`1)">
<summary>
 Combine the two arrays into an array of pairs. The two arrays must have equal lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.concat``1(System.Collections.Generic.IEnumerable`1{``0[]`1})">
<summary>
 Build a new array that contains the elements of each of the given sequence of arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.copy``1(``0[]`1)">
<summary>
 Build a new array that contains the elements of the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.create``1(System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.empty``1">
<summary>
 Return an empty array of the given type
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Test if any element of the array satisfies the given predicate.
 If the elements are <c>i0...iN</c> 
 then computes "p i0 or ... or p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.exists2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},``0[]`1,``1[]`1)">
<summary>
 Test elements of the two arrays pairwise to see if any pair of element satisfies the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.fill``1(``0[]`1,System.Int32,System.Int32,``0)">
<summary>
 Fill a range of an array with the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns "true"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.find``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Return the first element for which the given function returns 'true'.
 Raise <c>KeyNotFoundException</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.find_index``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if 
 none of the elements satisy the predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.find_indexi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}},``0[]`1)">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if 
 none of the elements satisy the predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.first``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},``0[]`1)">
<summary>
 Apply the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some <c>x</c>. If the function 
 never returns <c>Some(x)</c> then <c>None</c> is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.fold1_left``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.fold1_right``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.fold_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,``1[]`1)">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the elements are <c>i0...iN</c> then computes <c>f (... (f s i0)...) iN</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.fold_left2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``0}}},``0,``1[]`1,``2[]`1)">
<summary>
 Apply a function to pairs of elements drawn from the two collections, 
 left-to-right, threading an accumulator argument
 through the computation.  The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.fold_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},``0[]`1,``1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the elements are <c>i0...iN</c> then computes <c>f i0 (...(f iN s))</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.fold_right2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``2}}},``0[]`1,``1[]`1,``2)">
<summary>
 Apply a function to pairs of elements drawn from the two collections, right-to-left, 
 threading an accumulator argument through the computation.  The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Test if all elements of the array satisfy the given predicate.
 If the elements are <c>i0...iN</c> 
 then computes "p i0 &amp;&amp; ... &amp;&amp; p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.for_all2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},``0[]`1,``1[]`1)">
<summary>
 Test elements of the two arrays pairwise to see if all pairs of elements satisfy the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.get``1(``0[]`1,System.Int32)">
<summary>
 Fetch an element from an array.  You can also use the syntax 'arr.[idx]'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
 Create an array given the dimension and a generator function to compute the elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.is_empty``1(``0[]`1)">
<summary>
 Return true if the given array is empty, otherwise false
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[]`1)">
<summary>
 Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.iter2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}},``0[]`1,``1[]`1)">
<summary>
 Apply the given function to pair of elements drawn from matching indices in two arrays. The
 two arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},``0[]`1)">
<summary>
 Apply the given function to each element of the array.  The integer passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.iteri2``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}}},``0[]`1,``1[]`1)">
<summary>
 Apply the given function to pair of elements drawn from matching indices in two arrays,
 also passing the index of the elements. The two arrays must have the same lengths, 
 otherwise an <c>ArgumentException</c> is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.length``1(``0[]`1)">
<summary>
 Return the length of an array.  You can also use property arr.Length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.make``1(System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.map2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},``0[]`1,``1[]`1)">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.  The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},``0[]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer index passed to the
 function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.mapi2``3(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}}},``0[]`1,``1[]`1)">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise, also passing the index of 
 the elements.  The two input arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.max``1(``0[]`1)">
<summary>
 Return the greatest of all elements of the array, compared via Operators.max on the function result
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.max_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">
<summary>
 Return the greatest of all elements of the array, compared via Operators.max on the function result
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.min``1(``0[]`1)">
<summary>
 Return the lowest of all elements of the array, compared via Operators.min
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.min_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">
<summary>
 Return the lowest of all elements of the array, compared via Operators.min on the function result
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.of_list``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Build an array from the given list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.of_seq``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build a new array from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.partition``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Split the collection into two collections, containing the 
 elements for which the given predicate returns "true" and "false"
 respectively 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.permute``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.Int32},``0[]`1)">
<summary>
 Returns an array with all elements permuted according to the
 specified permutation
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.reduce_left``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``0[]`1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the elements are <c>i0...iN</c> then computes <c>f (... (f i0 i1)...) iN</c>
 Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.reduce_right``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``0[]`1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the elements are <c>i0...iN</c> then computes <c>f i0 (...(f iN-1 iN))</c>
 Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.rev``1(``0[]`1)">
<summary>
 Return a new array with the elements in reverse order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.scan_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,``1[]`1)">
<summary>
 Like <c>fold_left</c>, but return the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.scan_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},``0[]`1,``1)">
<summary>
 Like <c>fold_right</c>, but return both the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.set``1(``0[]`1,System.Int32,``0)">
<summary>
 Set the value of an element in an array.  You can also use the syntax 'arr.[idx] &lt;- e'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sort``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},``0[]`1)">
<summary>
 Sort the elements of an array, using the given comparison function as the order 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sort_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">
<summary>
 Sort the elements of an array, using the given projection for the keys. Keys are compared using Operators.compare.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.split``2(Microsoft.FSharp.Core.Tuple`2{``0,``1}[]`1)">
<summary>
 Split an array of pairs into two arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sub``1(``0[]`1,System.Int32,System.Int32)">
<summary>
 Build a new array that contains the given subrange specified by
 starting index and length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sum``1(``0[]`1)">
<summary>
 Return the sum of the elements in the array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sumByFloat``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Double},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.sumByFloat32``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Single},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.sumByInt``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.sumByInt64``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Int64},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.sum_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">
<summary>
 Return the sum of the results generated by applying the function to each element of the array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.to_list``1(``0[]`1)">
<summary>
 Build a list from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.to_seq``1(``0[]`1)">
<summary>
 Return a view of the array as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.tryfind``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Return the first element for which the given function returns <c>true</c>.
 Return <c>None</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.tryfind_index``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.tryfind_indexi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}},``0[]`1)">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.unzip``2(Microsoft.FSharp.Core.Tuple`2{``0,``1}[]`1)">
<summary>
 Split an array of pairs into two arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.unzip3``3(Microsoft.FSharp.Core.Tuple`3{``0,``1,``2}[]`1)">
<summary>
 Split an array of triples into three arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.zero_create``1(System.Int32)">
<summary>
 Create an array where the entries are initially the default value Unchecked.defaultof&lt;'a&gt;. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.zip``2(``0[]`1,``1[]`1)">
<summary>
 Combine the two arrays into an array of pairs. The two arrays must have equal lengths, otherwise an <c>ArgumentException</c> is
 raised..
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.zip3``3(``0[]`1,``1[]`1,``2[]`1)">
<summary>
 Combine three arrays into an array of pairs. The three arrays must have equal lengths, otherwise an <c>ArgumentException</c> is
 raised..
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Array">
<summary>
 Basic operations on arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.FromFunction``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}})">
<summary>
 Compare using the given comparer function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.GetFastComparisonFunction``1(System.Collections.Generic.IComparer`1{``0})">
<summary>
 Convert an existing IComparer object into a comparison function with a fast entry point
 If comparer was originally built using ComparisonIdentity.FromFunction then the original function will be
 returned
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.GetFastStructuralComparisonFunction``1">
<summary>
 Convert an existing IComparer objec tinto a comparison function with a fast entry point
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.Structural``1">
<summary>
 Structural comparison.  Compare using Operators.compare.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ComparisonIdentity">
<summary>
 Common notions of comparison identity used with sorted data structures.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.FromFunctions``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}})">
<summary>
 Hash using the given hashing and equality functions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.Reference``1">
<summary>
 Physical hashing (hash on reference identity of objects, and the contents of value types).  
 Hash using LanguagePrimitives.PhysicalEquality and LanguagePrimitives.PhysicalHash,
 That is, for value types use GetHashCode and Object.Equals (if no other optimization available),
 and for reference types use System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode and 
 reference equality. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.Structural``1">
<summary>
 Structural hashing.  Hash using Operators.(=) and Operators.hash.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.HashIdentity">
<summary>
 Common notions of value identity used with hash tables.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.append``1(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return a new list that contains the elements of the first list
 followed by elements of the second
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.average``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return the average of the elements in the list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.average_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return the average of the elements generated by applying the function to each element of the list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.choose``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Apply the given function to each element of the list. Return
 the list comprised of the results <c>x</c> for each element where
 the function returns Some(x)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.combine``2(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">
<summary>
 A synonym for List.zip
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.concat``1(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Collections.List`1{``0}})">
<summary>
 Return a new list that contains the elements of each the lists in order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.empty``1">
<summary>
 Return an empty list of the given type
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Test if any element of the collection satisfies the given predicate.
 If the elements are <c>i0...iN</c> 
 then computes <c>p i0 or ... or p iN</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.exists2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">
<summary>
 Test if all corresponding elements of the collection satisfy the given predicate pairwise.

 The predicate is applied to matching elements in the two lists up to the lesser of the 
 two lengths of the lists. If any application returns true then the overall result is 
 true. Otherwise, if one list is longer than the other then the <c>ArgumentException</c> exception is raised. 
 Otherwise, false is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns "true"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.find``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return the first element for which the given function returns <c>true</c>.
 Raise <c>KeyNotFoundException</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.find_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return a list containing all the elements for which the given function returns
 "true".  Same as "filter"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.find_index``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return the index of the first element in the list
 that satisfies the given predicate.
 Raise <c>KeyNotFoundException</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.find_indexi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return the index of the first element in the list
 that satisfies the given predicate.
 Raise <c>KeyNotFoundException</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.first``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Apply the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some x.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.flatten``1(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Collections.List`1{``0}})">
<summary>
 Return a new list that contains the elements of each the lists in order.
 Same as concat.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.fold1_left``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.fold1_right``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.fold_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Collections.List`1{``1})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. Take the second argument, and apply the function to it
 and the first element of the list.  Then feed this result into the function along
 with the second element and so on.  Return the final result.
 If the elements are <c>i0...iN</c> then computes <c>f (... (f s i0) i1 ...) iN</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.fold_left2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``0}}},``0,Microsoft.FSharp.Collections.List`1{``1},Microsoft.FSharp.Collections.List`1{``2})">
<summary>
 Apply a function to corresponding elements of two collections, threading an accumulator argument
 through the computation. The collections must have identical sizes.
 If the elements are <c>i0...iN</c> and "j0...jN"
 then computes "f (... (f s i0 j0)...) iN jN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.fold_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Collections.List`1{``0},``1)">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the elements are <c>i0...iN</c> then computes <c>f i0 (...(f iN s))</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.fold_right2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``2}}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1},``2)">
<summary>
 Apply a function to corresponding elements of two collections, threading an accumulator argument
 through the computation. The collections must have identical sizes.
 If the elements are <c>i0...iN</c> and "j0...jN"
 then computes "f i0 j0 (...(f iN jN s))".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Test if all elements of the collection satisfy the given predicate.
 If the elements are <c>i0...iN</c> 
 then computes <c>p i0 &amp;&amp; ... &amp;&amp; p iN</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.for_all2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">
<summary>
 Test if all corresponding elements of the collection satisfy the given predicate pairwise.

 The predicate is applied to matching elements in the two lists up to the lesser of the 
 two lengths of the lists. If any application returns false then the overall result is 
 false. Otherwise, if one list is longer than the other then the <c>ArgumentException</c> exception is raised. 
 Otherwise, true is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.hd``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return the first element of the list.  Raise (Invalid_argument "hd") if undefined.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
 Create a list by calling the given generator on each index
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.is_empty``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return true if the list contains no elements, false otherwise
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Apply the given function to each element of the collection. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.iter2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">
<summary>
 Apply the given function to two collections simultaneously. The
 collections must have identical size.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Apply the given function to each element of the collection. The integer passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.iteri2``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">
<summary>
 Apply the given function to two collections simultaneously. The
 collections must have identical size. The integer passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.length``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return the length of the list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.map2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.map3``4(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``3}}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1},Microsoft.FSharp.Collections.List`1{``2})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the three collections simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.map_concat``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Collections.List`1{``1}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 For each element of the list, apply the given function. Concatenate all the results and return the combined list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The integer index passed to the
 function indicates the index (from 0) of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.mapi2``3(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">
<summary>
 Like mapi, but mapping corresponding elements from two lists of equal length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.max``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return the greatest of all elements of the list, compared via Operators.max
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.max_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return the greatest of all elements of the array, compared via Operators.max on the function result
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.min``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return the lowest of all elements of the list, compared via Operators.min
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.min_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return the lowest of all elements of the array, compared via Operators.min on the function result
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.nth``1(Microsoft.FSharp.Collections.List`1{``0},System.Int32)">
<summary>
 Index into the list.  The first element has index 0.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.of_array``1(``0[]`1)">
<summary>
 Build a collection from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.of_seq``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build a new collection from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.partition``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Split the collection into two collections, containing the 
 elements for which the given predicate returns <c>true</c> and <c>false</c>
 respectively 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.permute``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.Int32},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Returns a list with all elements permuted according to the
 specified permutation
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.reduce_left``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. Apply the function to the first two elements of the list.
 Then feed this result into the function along with the third element and so on.  
 Return the final result. 
 If the elements are <c>i0...iN</c> then computes "f (... (f i0 i1) i2 ...) iN"
 Raises ArgumentException if the list has no elements.      
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.reduce_right``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the elements are <c>i0...iN</c> then computes "f i0 (...(f iN-1 iN))".
 Raises ArgumentException if the list has no elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.rev``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return a new list with the elements in reverse order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.scan_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Collections.List`1{``1})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. Take the second argument, and apply the function to it
 and the first element of the list.  Then feed this result into the function along
 with the second element and so on.  Return the list of intermediate results and the final result.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.scan_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Collections.List`1{``0},``1)">
<summary>
 Like <c>fold_right</c>, but return both the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.sort``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Sort the given list using the given comparison function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.sort_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Sort the given list using the given comparison function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.split``2(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 A synonym for List.unzip
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.stable_sort``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Sort the given list using the given comparison function, preserving order for equal elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.sum``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return the sum of the elements in the list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.sumByFloat``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Double},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.sumByFloat32``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Single},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.sumByInt``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.sumByInt64``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Int64},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.sum_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return the sum of the results generated by applying the function to each element of the list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.tl``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return the tail of the list.  Raise (Invalid_argument "tl") if undefined.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.to_array``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Build an array from the given collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.to_seq``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return a view of the collection as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.tryfind``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return the first element for which the given function returns <c>true</c>.
 Return <c>None</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.tryfind_index``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return the index of the first element in the list
 that satisfies the given predicate.
 Return <c>None</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.tryfind_indexi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Return the index of the first element in the list
 that satisfies the given predicate.
 Return <c>None</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.unzip``2(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Split a list of pairs into two lists
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.unzip3``3(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`3{``0,``1,``2}})">
<summary>
 Split a list of triples into three lists
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.zip``2(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">
<summary>
 Combine the two lists into a list of pairs. The two lists must have equal lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.zip3``3(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1},Microsoft.FSharp.Collections.List`1{``2})">
<summary>
 Combine the three lists into a list of triples. The lists must have equal lengths.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.List">
<summary>
 Basic operations on lists.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.add``2(``0,``1,Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Return a new map with the binding added to the given map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.empty``2">
<summary>
 The empty map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.exists``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Return true if the given predicate returns true for one of the
 bindings in the map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.filter``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Build a new map containing only the bindings for which the given predicate returns 'true'
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.find``2(``0,Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Lookup an element in the map, raising <c>KeyNotFoundException</c> if no binding
 exists in the map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.find_index``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Evaluates the function on each mapping in the collection. Returns the key for the first mapping
 where the function returns 'trye'. Raise <c>KeyNotFoundException</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.first``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Option`1{``2}}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Search the map looking for the first element where the given function returns a <c>Some</c> value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.fold_left``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``0}}},``0,Microsoft.FSharp.Collections.Map`2{``1,``2})">

</member>
<member name="M:Microsoft.FSharp.Collections.Map.fold_right``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``2}}},Microsoft.FSharp.Collections.Map`2{``0,``1},``2)">
<summary>
 Fold over the bindings in the map 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.for_all``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Return true if the given predicate returns true for all of the
 bindings in the map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.is_empty``2(Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Is the map empty?
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.iter``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Apply the given function to each binding in the dictionary
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.map``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.Map`2{``2,``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.mapi``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The index passed to the
 function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.mem``2(``0,Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Test is an element is in the domain of the map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.of_array``2(Microsoft.FSharp.Core.Tuple`2{``0,``1}[]`1)">
<summary>
 Return a new map made from the given bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.of_list``2(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Return a new map made from the given bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.of_seq``2(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Return a new map made from the given bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.partition``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Build two new maps, one containing the bindings for which the given predicate returns 'true',
 and the other the remaining bindings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.remove``2(``0,Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Remove an element from the domain of the map.  No exception is raised if the element is not present.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.to_array``2(Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Returns an array of all key-value pairs in the mappinng
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.to_list``2(Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Returns a list of all key-value pairs in the mappinng
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.to_seq``2(Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 View the collection as an enumerable sequence. This collection
 type is also directly compatible with 'seq&lt;KeyValuePair&lt;_,_&gt; &gt;'.

 Note this function returns a sequence of tuples, whereas the collection
 itself is compatible with the logically equivalent sequence of KeyValuePairs.
 Using sequences of tuples tends to be more convenient in F#, however the
 collection itself must enumerate KeyValuePairs to conform to the .NET
 design guidelines and the IDictionary interface.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.tryfind``2(``0,Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Lookup an element in the map, returning a <c>Some</c> value if the element is in the domain 
 of the map and <c>None</c> if not.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.tryfind_index``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Return the key of the first mapping in the collection that satisfies the given predicate. 
 Return 'None' if no such element exists.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Map">
 <summary>
   Immutable maps using structural comparison
 </summary>

 <performance> Maps based on structural comparison are  
 efficient. They are not a suitable choice if keys are recursive data structures 
 or require non-structural comparison semantics.</performance>
</member>
<member name="T:Microsoft.FSharp.Collections.ResizeArray.t`1">

</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.append``1(System.Collections.Generic.List`1{``0},System.Collections.Generic.List`1{``0})">
<summary>
Build a new array that contains the elements of the first array followed by the elements of the second array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.blit``1(System.Collections.Generic.List`1{``0},System.Int32,System.Collections.Generic.List`1{``0},System.Int32,System.Int32)">
<summary>
Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.choose``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},System.Collections.Generic.List`1{``0})">
<summary>
Apply the given function to each element of the array. Return
the array comprised of the results "x" for each element where
the function returns Some(x)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.combine``2(System.Collections.Generic.List`1{``0},System.Collections.Generic.List`1{``1})">
<summary>
Combine the two arrays into an array of pairs. The two arrays must have equal lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.concat``1(Microsoft.FSharp.Collections.List`1{System.Collections.Generic.List`1{``0}})">
<summary>
Build a new array that contains the elements of each of the given list of arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.copy``1(System.Collections.Generic.List`1{``0})">
<summary>
Build a new array that contains the elements of the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.create``1(System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.List`1{``0})">
<summary>
Test if any element of the array satisfies the given predicate.
If the elements are <c>i0...iN</c> 
then computes "p i0 or ... or p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.exists2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},System.Collections.Generic.List`1{``0},System.Collections.Generic.List`1{``1})">
<summary>
 Test elements of the two arrays pairwise to see if any pair of element satisfies the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.fill``1(System.Collections.Generic.List`1{``0},System.Int32,System.Int32,``0)">
<summary>
Fill a range of the collection with the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.List`1{``0})">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns "true"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.find``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.List`1{``0})">
<summary>
Return the first element for which the given function returns <c>true</c>.
Raise <c>KeyNotFoundException</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.find_index``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.List`1{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if 
 none of the elements satisy the predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.find_indexi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}},System.Collections.Generic.List`1{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if 
 none of the elements satisy the predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.first``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},System.Collections.Generic.List`1{``0})">
<summary>
Apply the given function to successive elements, returning the first
result where function returns "Some(x)" for some x.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.fold_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,System.Collections.Generic.List`1{``1})">
<summary>
Apply a function to each element of the collection, threading an accumulator argument
through the computation. If the elements are <c>i0...iN</c> then computes <c>f (... (f s i0)...) iN</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.fold_left2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``0}}},``0,System.Collections.Generic.List`1{``1},System.Collections.Generic.List`1{``2})">
<summary>
 Apply a function to pairs of elements drawn from the two collections, 
 left-to-right, threading an accumulator argument
 through the computation.  The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.fold_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},System.Collections.Generic.List`1{``0},``1)">
<summary>
Apply a function to each element of the array, threading an accumulator argument
through the computation. If the elements are <c>i0...iN</c> then computes <c>f i0 (...(f iN s))</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.fold_right2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``2}}},System.Collections.Generic.List`1{``0},System.Collections.Generic.List`1{``1},``2)">
<summary>
 Apply a function to pairs of elements drawn from the two collections, right-to-left, 
 threading an accumulator argument through the computation.  The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.List`1{``0})">
<summary>
Test if all elements of the array satisfy the given predicate.
If the elements are <c>i0...iN</c> and "j0...jN"
then computes "p i0 &amp;&amp; ... &amp;&amp; p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.for_all2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},System.Collections.Generic.List`1{``0},System.Collections.Generic.List`1{``1})">
<summary>
 Test elements of the two arrays pairwise to see if all pairs of elements satisfy the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.get``1(System.Collections.Generic.List`1{``0},System.Int32)">
<summary>
 Fetch an element from the collection.  You can also use the syntax <c>arr.[idx]</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
 Create an array by calling the given generator on each index.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.is_empty``1(System.Collections.Generic.List`1{``0})">
<summary>
 Return true if the given array is empty, otherwise false
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.List`1{``0})">
<summary>
Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.iter2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List`1{``0},System.Collections.Generic.List`1{``1})">
<summary>
Apply the given function to two arrays simultaneously. The
two arrays must have the same lengths, otherwise an Invalid_argument exception is
raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List`1{``0})">
<summary>
Apply the given function to each element of the array.  The integer passed to the
function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.iteri2``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}}},System.Collections.Generic.List`1{``0},System.Collections.Generic.List`1{``1})">
<summary>
 Apply the given function to pair of elements drawn from matching indices in two arrays,
 also passing the index of the elements. The two arrays must have the same lengths, 
 otherwise an <c>ArgumentException</c> is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.length``1(System.Collections.Generic.List`1{``0})">
<summary>
 Return the length of the collection.  You can also use property <c>arr.Length</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.List`1{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.map2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},System.Collections.Generic.List`1{``0},System.Collections.Generic.List`1{``1})">
<summary>
Build a new collection whose elements are the results of applying the given function
to the corresponding elements of the two collections pairwise.  The two input
arrays must have the same lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},System.Collections.Generic.List`1{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array. The integer index passed to the
function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.mapi2``3(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}}},System.Collections.Generic.List`1{``0},System.Collections.Generic.List`1{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.  The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.of_list``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Build an array from the given list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.partition``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.List`1{``0})">
<summary>
Split the collection into two collections, containing the 
elements for which the given predicate returns "true" and "false"
respectively 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.reduce_left``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},System.Collections.Generic.List`1{``0})">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the elements are <c>i0...iN</c> then computes <c>f (... (f i0 i1)...) iN</c>
 Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.reduce_right``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},System.Collections.Generic.List`1{``0})">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the elements are <c>i0...iN</c> then computes "f i0 (...(f iN-1 iN))"
 Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.rev``1(System.Collections.Generic.List`1{``0})">
<summary>
Return a new array with the elements in reverse order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.scan_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,System.Collections.Generic.List`1{``1})">
<summary>
 Like <c>fold_left</c>, but return the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.scan_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},System.Collections.Generic.List`1{``0},``1)">
<summary>
 Like <c>fold_right</c>, but return both the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.set``1(System.Collections.Generic.List`1{``0},System.Int32,``0)">
<summary>
 Set the value of an element in the collection.  You can also use the syntax <c>arr.[idx] &lt;- e</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.singleton``1(``0)">
<summary>
 Return an array containing the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.sort``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},System.Collections.Generic.List`1{``0})">
<summary>
 Sort the elements using the given comparison function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.sort_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.List`1{``0})">
<summary>
 Sort the elements using the key extractor and generic comparison on the keys
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.split``2(System.Collections.Generic.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
Split a list of pairs into two lists
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.sub``1(System.Collections.Generic.List`1{``0},System.Int32,System.Int32)">
<summary>
Build a new array that contains the given subrange specified by
starting index and length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.to_list``1(System.Collections.Generic.List`1{``0})">
<summary>
Build a list from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.to_seq``1(System.Collections.Generic.List`1{``0})">
<summary>
 Return a view of the array as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.tryfind``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.List`1{``0})">
<summary>
Return the first element for which the given function returns <c>true</c>.
Return None if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.tryfind_index``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.List`1{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.tryfind_indexi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}},System.Collections.Generic.List`1{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.unzip``2(System.Collections.Generic.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Split an array of pairs into two arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.zip``2(System.Collections.Generic.List`1{``0},System.Collections.Generic.List`1{``1})">
<summary>
 Combine the two arrays into an array of pairs. The two arrays must have equal lengths, otherwise an <c>ArgumentException</c> is
 raised..
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ResizeArray">
<summary>
 Generic operations on the type System.Collections.Generic.List, which is called ResizeArray in the F# libraries.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.CachedSeq`1.Clear">
<summary>
 Clear any data or partial enumeration stored in the cache. Subsequent enumerations will start again
 from the first element with a fresh enumerator.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Seq.CachedSeq`1">
<summary>
 A CachedSeq is the value returned by Seq.cache. It is a sequence object that also is IDisposable.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.append``1(System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Wrap the two given enumeration-of-enumerations as a single concatenated
 enumeration.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed from
 multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.average``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the average of the elements in the sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.average_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the average of the results generated by applying the function to each element of the sequence.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.cache``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a CachedSeq for a sequence that corresponds to a cached version of the input sequence.
 This result sequence will have the same elements as the input sequence.
 The result can be enumerated multiple times.
 The input sequence will be enumerated at most once and only as far as is necessary (it's enumeration is cached).

 Enumeration of the result sequence is thread safe in the sense that multiple independent IEnumerator
 values may be used simultaneously from different threads (accesses to 
 the internal lookaside table are thread safe). Each individual IEnumerator
 is not typically thread safe and should not be accessed from multiple threads simultaneously.

 Note, once enumeration of the input sequence has started,
 it's enumerator will be held on to by this object until the enumeration has completed.
 At that point, the enumerator will be disposed. 

 The enumerator and underlying cache storage may be released by disposing or clearing the CachedSeq. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.cast``1(System.Collections.IEnumerable)">
<summary>
 Wrap a loosely-typed System.Collections sequence as a typed sequence.

 The use of this function usually requires a type annotation.
 An incorrect type annotation may result in runtime type
 errors.

 Individual IEnumerator values generated from the returned sequence should not be accessed from
 multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.choose``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply the given function to each element of the list. Return
 the list comprised of the results "x" for each element where
 the function returns Some(x)

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed from
 multiple threads simultaneously.

 Remember sequence is lazy, effects are delayed until it is enumerated.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.compare``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Compare two sequence's using the given comparison function.  Both
 input IEnumerables are assumed to be in a canonical order (i.e. sorted)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.concat``2(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Wrap the given enumeration-of-enumerations as a single concatenated
 enumeration.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed from
 multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.countBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.count_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply a key-generating function to each element of a sequence and return a sequence yielding unique
 keys and their number of occurences in the original sequence.  
 
 Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.delay``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,System.Collections.Generic.IEnumerable`1{``0}})">
<summary>
 Return a sequence that is built from the given delayed specification of an
 Seq. The input function is evaluated each time an IEnumerator for the sequence 
 is requested.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.distinct``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a sequence that contains no duplicate entries according to generic hash and equality comparisons on the entries.
 If an element occurs multiple times in the sequence then the later occurrences are discarded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.distinct_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a sequence that contains no duplicate entries according to the 
 generic hash and equality comparisons on the keys returned by the given key-generating function.
 If an element occurs multiple times in the sequence then the later occurrences are discarded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.empty``1">
<summary>
 Create an empty sequence 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Test if any element of the collection satisfies the given predicate.
 If the elements are <c>i0...iN</c> then computes "p i0 or ... or p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.exists2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``1})">
<summary>
 Test the any pair of elements drawn from the two sequences satisfies the
 given predicate. If one sequence is shorter than 
 the other than the remaining elements of the longer sequence are ignored
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns "true"

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed from
 multiple threads simultaneously.

 Remember sequence is lazy, effects are delayed until it is enumerated.      
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.find``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the first element for which the given function returns <c>true</c>.
 Raise <c>KeyNotFoundException</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.find_index``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``1,``0}})">
<summary>
 Return the index of the first element in the sequence of pairs
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.find_indexi``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Return the index of the first element in the sequence of pairs
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.first``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply the given function to successive elements, returning the first
 result where function returns "Some(x)" for some x.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.fold``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,System.Collections.Generic.IEnumerable`1{``1})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the elements are <c>i0...iN</c> then computes <c>f (... (f s i0)...) iN</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.fold1``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply a function to each element of the sequence, threading an accumulator argument
 through the computation. Begin by applying the function to the first two elements.
 Then feed this result into the function along with the third element and so on.  
 Return the final result.
 Raises ArgumentException if the sequence has no elements.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Test if all elements of the collection satisfy the given predicate.
 If the elements are <c>i0...iN</c> then computes "p i0 &amp;&amp; ... &amp;&amp; p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.for_all2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``1})">
<summary>
 Test the all pairs of elements drawn from the two sequences satisfies the
 given predicate. If one sequence is shorter than 
 the other than the remaining elements of the longer sequence are ignored
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.groupBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.group_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply a key-generating function to each element of a sequence and yields a sequence of 
 unique keys. Each unique key has also contains a sequence of all elements that match 
 to this key. 
 
 Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.hd``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the first element of the sequence.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.init_finite``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
 Generate a new sequence which, when iterated, will return successive
 elements by calling the given function, up to the given count.  The results of calling the function
 will not be saved, i.e. the function will be reapplied as necessary to
 regenerate the elements.  The function is passed the index of the item being
 generated.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed from
 multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.init_infinite``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
 Generate a new sequence which, when iterated, will return successive
 elements by calling the given function.  The results of calling the function
 will not be saved, i.e. the function will be reapplied as necessary to
 regenerate the elements.  The function is passed the index of the item being
 generated

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed from
 multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.is_empty``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return true if the sequence contains no elements, false otherwise
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply the given function to each element of the collection. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.iter2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``1})">
<summary>
 Apply the given function to two collections simultaneously. If one sequence is shorter than 
 the other than the remaining elements of the longer sequence are ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply the given function to each element of the collection. The integer passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.length``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the length of the sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.  The function will be applied
 as elements are demanded using the 'Current' property on iterators retrieved from the
 object.  Generating multiple iterators or calling the 'Current' property multiple
 times may result in the function being called multiple times.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed from
 multiple threads simultaneously.

 Remember sequence is lazy, effects are delayed until it is enumerated.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.map2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding pairs of elements from the two sequences. If one input sequence is shorter than 
 the other than the remaining elements of the longer sequence are ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.map_concat``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 For each element of the enumeration apply the given function and concatenate all the results.

 Remember sequence is lazy, effects are delayed until it is enumerated.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The integer index passed to the
 function indicates the index (from 0) of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.max``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the greatest of all elements of the sequence, compared via Operators.max
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.max_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the greatest of all elements of the array, compared via Operators.max on the function result
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.min``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the lowest of all elements of the sequence, compared via Operators.min
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.min_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the lowest of all elements of the array, compared via Operators.min on the function result
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.nth``1(System.Int32,System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Compute the nth element in the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.of_array``1(``0[]`1)">
<summary>
 Build a collection from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.of_list``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Build a collection from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.orderBy``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.pairwise``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a sequence of each element in the input sequence and its predecessor, with the
 exception of the first element which is only returned as the predecessor of the second element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.readonly``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build a new sequence object that delegates to the given sequence object. This ensures 
 the original sequence can't be rediscovered and mutated by a type cast. For example, 
 if given an array the returned sequence will return the elements of the array, but
 you can't cast the returned sequence object to an array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.reduce``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply a function to each element of the sequence, threading an accumulator argument
 through the computation. Begin by applying the function to the first two elements.
 Then feed this result into the function along with the third element and so on.  
 Return the final result.
 Raises ArgumentException if the sequence has no elements.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.scan``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,System.Collections.Generic.IEnumerable`1{``1})">
<summary>
 Like fold, but compute on-demand and return the sequence of intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.scan1``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Like reduce, but compute on-demand and return the sequence of intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.singleton``1(``0)">
<summary>
 Return a sequence that yields one item only.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.skip``1(System.Int32,System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a sequence that skips N elements of the underlying sequence and then yields the
 remaining elements of the sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.skip_while``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a sequence that, when iterated, skips elements of the underlying sequence while the 
 given predicate returns 'true', and then yields the remaining elements of the sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sort``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Yield a sequence ordered by keys.  
 
 Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sort_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Apply a key-generating function to each element of a sequence and yields a sequence ordered
 by keys.  
 
 Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sum``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the sum of the elements in the sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sumByFloat``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Double},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sumByFloat32``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Single},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sumByInt``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sumByInt64``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Int64},System.Collections.Generic.IEnumerable`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sum_by``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the sum of the results generated by applying the function to each element of the sequence.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.take``1(System.Int32,System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the first N elements of the sequence.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.take_while``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a sequence that, when iterated, yields elements of the underlying sequence while the 
 given predicate returns 'true', and returns no further elements 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.to_array``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build an array from the given collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.to_list``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build a list from the given collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.truncate``1(System.Int32,System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a sequence that when enumerated returns at most N elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.tryfind``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return the first element for which the given function returns <c>true</c>.
 Return <c>None</c> if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.tryfind_index``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``1,``0}})">
<summary>
 Return the index of the first element in the sequence of pairs
 that satisfies the given predicate. Return 'None' if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.tryfind_indexi``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Return the index of the first element in the sequence of pairs
 that satisfies the given predicate. Return 'None' if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.unfold``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Core.Tuple`2{``1,``0}}},``0)">
<summary>
 Return a sequence that contains the elements generated by the given computation.
 The given initial 'state' argument is passed to the element generator.
 For each IEnumerator elements in the stream are generated on-demand by applying the element
 generator, until a None value is returned by the element generator. Each call to the element
 generator returns a new residual 'state'.

 Note the stream will be recomputed each time an IEnumerator is requested and iterated for the Seq.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed from
 multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.windowed``1(System.Int32,System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Return a sequence that yields 'sliding windows' of containing elements drawn from the input
 sequence. Each window is returned as a fresh array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.zip``2(System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``1})">
<summary>
 Combine the two sequences into a list of pairs. The two sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequence are ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.zip3``3(System.Collections.Generic.IEnumerable`1{``0},System.Collections.Generic.IEnumerable`1{``1},System.Collections.Generic.IEnumerable`1{``2})">
<summary>
 Combine the three sequences into a list of triples. The two sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequence are ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.SequenceExpressionHelpers.do_finally``1(System.Collections.Generic.IEnumerable`1{``0},Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 The F# compiler emits calls to this function to 
 implement the 'try/finally' operator for F# sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.SequenceExpressionHelpers.generate``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.SequenceExpressionHelpers.generate_using``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}})">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.SequenceExpressionHelpers.generated``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,System.Boolean},System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 The F# compiler emits calls to this function to 
 implement the 'while' operator for F# sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.SequenceExpressionHelpers.of_functions``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 The F# compiler emits calls to this function to implement the compiler-intrinsic
 conversions from untyped System.Collections.IEnumerable sequences to typed sequences
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.SequenceExpressionHelpers.using``3(``0,Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 The F# compiler emits calls to this function to 
 implement the 'use' operator for F# sequence expressions
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Seq.SequenceExpressionHelpers">

</member>
<member name="T:Microsoft.FSharp.Collections.Seq">
<summary>
 Basic operations on IEnumerables.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.add``1(``0,Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Return a new set with an element added to the set.  No exception is raised if
the set already contains the given element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.choose``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Choose an arbitrary element from a set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.compare``1(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Compare two sets. Places sets into a total order. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.count``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return the number of elements in the set.  Same as "size"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.diff``1(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return a new set with the elements of the second set
removed from the first.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.empty``1">
<summary>
The empty set.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.equal``1(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Test if two sets are equal
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Test if any element of the collection satisfies the given predicate.
If the elements are <c>i0...iN</c> 
then computes "p i0 or ... or p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns "true"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.fold_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Collections.Set`1{``1})">
<summary>
Apply the given accumulating function to all the elements of the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.fold_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Collections.Set`1{``0},``1)">
<summary>
Apply the given accumulating function to all the elements of the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Test if all elements of the collection satisfy the given predicate.
If the elements are <c>i0...iN</c> and "j0...jN"
then computes "p i0 &amp;&amp; ... &amp;&amp; p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.intersect``1(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Compute the intersection of the two sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.intersect_all``1(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Collections.Set`1{``0}})">
<summary>
Compute the intersection of a sequence of sets. The sequence must be non-empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.is_empty``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return "true" if the set is empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Apply the given function to each element of the set, in order according
to the comparison function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return a new collection containing the results of applying the
given function to each element of the input set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.max_elt``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Returns the highest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.mem``1(``0,Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Evaluates to "true" if the given element is in the given set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.min_elt``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Returns the lowest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.next_elt``1(``0,Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Returns the least element in the set that is greater than the given key 
 according to the ordering being used for the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.of_array``1(``0[]`1)">
<summary>
 Build a set that contains the same elements as the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.of_list``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Build a set that contains the same elements as the given list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.of_seq``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build a new collection from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.partition``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Split the set into two sets containing the elements for which the given predicate
returns true and false respectively
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.prev_elt``1(``0,Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Returns the greatest element in the set that is less than the given key 
 according to the ordering being used for the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.remove``1(``0,Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return a new set with the given element removed.  No exception is raised in 
the set doesn't contain the given element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.singleton``1(``0)">
<summary>
The set containing the given one element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.size``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return the number of elements in the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.subset``1(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Evaluates to "true" if all elements of the first set are in the second
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.to_array``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Build an array that contains the elements of the set in order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.to_list``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Build a list that contains the elements of the set in order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.to_seq``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Return a view of the collection as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.union``1(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Compute the union of the two sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.union_all``1(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Collections.Set`1{``0}})">
<summary>
Compute the union of a sequence of sets.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Set">

</member>
<member name="P:Microsoft.FSharp.Control.Async.Done">
<summary>
 "Done" generates an asynchronous computation that, when run, yields the value 'unit' immediately
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Async.DefaultGroup">
<summary>
 Get the default group for executing asynchronous computations
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.WhenCancelled``1(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.FastFunc`2{System.OperationCanceledException,Microsoft.FSharp.Core.Unit})">
<summary>
 Specify an asynchronous computation that, when run, executes <c>computation</c>,
 If <c>p</c> is effectively cancelled before its termination then
 the process <c>f exn</c> is executed. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Using``2(``0,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Control.Async`1{``1}})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.UnblockedPrimitive``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Run a primitive blocking operation on a brand new thread. Execute the continuation as a worker
 item in the thread pool.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.TryFinally``1(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.SwitchToThreadPool">
<summary>
 Specify an asynchronous computation that, when run, queues a CPU-intensive work in the thread pool item that runs
 its continutation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.SwitchToNewThread">
<summary>
 Specify an asynchronous computation that, when run, creates a new thread and runs
 its continutation in that thread
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.SwitchTo(System.Threading.SynchronizationContext)">
<summary>
 Specify an asynchronous computation that, when run, runs
 its continuation using syncContext.Post. If syncContext is null then the asynchronous
 computation is equivalent to SwitchToThreadPool().
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.SpawnThenPostBack``1(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit})">
<summary>
 Start the asynchronous computation in the thread pool. When the result is available 
 execute the given postBack in the synchronization context of the thread that originally called Run.
 This will frequently be the GUI thread, and in that case the postBack will be executed by sending a 'BeginInvoke' to the
 GUI message loop.  If the System.Threading.SynchronizationContext.Current of the calling thread is 'null'
 then a FailureException is raised.

 If an exception occurs in the asynchronous computation then it is posted as a 
 function that raises an exception in the synchronization context of the thread that originally called RunThenPostBack. 

 Run as part of the default AsyncGroup
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.SpawnFuture``1(Microsoft.FSharp.Control.Async`1{``0})">
<summary>
 Start the asynchronous computation in the .NET thread pool, initially as a CPU-intensive worker item. 
 Return a handle to the computation as an AsyncFuture.

 Run as part of the default AsyncGroup
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.SpawnChild(Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit})">
<summary>
 Start the asynchronous computation in the thread pool, and add it to the AsyncGroup of 
 of the asynchronous computation. Do not await its result. Exceptions in the asynchronous 
 computation are currently ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Spawn(Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit})">
<summary>
 Start the asynchronous computation in the thread pool. Do not await its result.

 Run as part of the default AsyncGroup
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.RunPrimitive``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FastFunc`2{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FastFunc`2{System.OperationCanceledException,Microsoft.FSharp.Core.Unit})">
<summary>
 Start the asynchronous computation in the .NET thread pool, initially as a CPU-intensive worker item. 
 Return a handle to the computation as an AsyncFuture.

 Run as part of the default AsyncGroup
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Run``1(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Boolean})">
<summary>
 Run the asynchronous computation and await its result.

 If an exception occurs in the asynchronous computation then an exception is re-raised by this
 function.

 Run as part of the default AsyncGroup
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Return``1(``0)">
<summary>
 "Return x" generates an asynchronous computation that, when run, yields the value "x" immediately
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Raise``1(System.Exception)">
<summary>
 "Raise exn" generates an asynchronous computation that, when run terminates by raising 
 the given exception, i.e. the given exception is passed to the exception continuation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Primitive``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`2{Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FastFunc`2{System.Exception,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Unit})">
<summary>
 Specify an asynchronous computation that, when run, executes the given callback. The callback must eventually call either the continuation
 or the exception continuation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Primitive``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`3{Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FastFunc`2{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FastFunc`2{System.OperationCanceledException,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Unit})">
<summary>
 Specify an asynchronous computation that, when run, executes the given callback. 
 The callback must eventually call either the continuation,
 the exception continuation or the cancel exception.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Parallel3``3(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Control.Async`1{``1},Microsoft.FSharp.Control.Async`1{``2})">
<summary>
 Specify an asynchronous computation that, when run, executese the three asynchronous computations, starting each in the thread pool.
 If any raise an exception then the overall computation will raise an exception, and attempt to cancel the others.
 All the sub-computations belong to an AsyncGroup that is a subsidiary of the AsyncGroup of the outer computations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Parallel2``2(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Control.Async`1{``1})">
<summary>
 Specify an asynchronous computation that, when run, executes the two asynchronous computations, starting each in the thread pool.
 If any raise an exception then the overall computation will raise an exception, and attempt to cancel the others.
 All the sub-computations belong to an AsyncGroup that is a subsidiary of the AsyncGroup of the outer computations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Parallel``1(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Control.Async`1{``0}})">
<summary>
 Specify an asynchronous computation that, when run, executes all the given asynchronous computations, initially
 queueing each in the thread pool. If any raise an exception then the 
 overall computation will raise an exception, and attempt to cancel the others.
 All the sub-computations belong to an AsyncGroup that is a subsidiary of the AsyncGroup of the outer computations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.OnCancel(Microsoft.FSharp.Core.FastFunc`2{System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 Generate a scoped, cooperative cancellation handler for use within an asynchronous workflow. 

 <c>async { use! holder = Async.OnCancel f ... }</c> generates an asynchronous computation where, 
 if a cancellation happens any time during the execution of the asynchronous computation in the scope of 'holder',
 then action 'f' is executed on the thread that is performing the cancellation. You can use
 this to arrange for your own computation to be asynchronously notified that a cancellation has occurred, e.g.
 by setting a flag, or deregistering a pending I/O action.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Ignore``1(Microsoft.FSharp.Control.Async`1{``0})">
<summary>
 Specify an asynchronous computation that, when run, runs 'p', ignoring the result and
 returning the result '()'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Generate``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Control.Async`1{``0}},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Generate asynchronous computations for indexes 0..N-1. Do so in the indicated number of parallel groups, which 
 defaults to the physical processor count on the machine. If any raise an exception attempt to cancel the others.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Delay``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Control.Async`1{``0}})">
<summary>
 "Delay f" generates an asynchronous computation that, when run, 
 runs the asynchronous computation "f x"
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Catch``1(Microsoft.FSharp.Control.Async`1{``0})">
<summary>
 Get the default group for executing asynchronous computations
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.CancelDefaultGroup(Microsoft.FSharp.Core.Option`1{System.String})">
<summary>
 Raise the cancellation condition for the most recent set of Async computations started without any specific AsyncGroup.
 Replace the global group with a new global group for any async computations created after this point without 
 any specific AsyncGroup.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.CancelCheck">
<summary>
 Specify an asynchronous computation that checks if the cancellation condition for the AsyncGroup to which this
 Async computation belongs has been set. If so the operation raises a System.OperationCanceledException.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.BuildPrimitive``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`2{System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FastFunc`2{System.IAsyncResult,``0})">
<summary>
 Specify an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in .NET APIs where the overall operation is not qualified by any arguments. For example, 
     Async.BuildPrimitive(ws.BeginGetWeather,ws.EndGetWeather)
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.BuildPrimitive``2(``0,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`3{``0,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FastFunc`2{System.IAsyncResult,``1})">
<summary>
 Specify an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in .NET APIs where the
 overall operation is qualified by one argument. For example, 
     Async.BuildPrimitive(place,ws.BeginGetWeather,ws.EndGetWeather)
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.BuildPrimitive``3(``0,``1,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`4{``0,``1,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FastFunc`2{System.IAsyncResult,``2})">
<summary>
 Specify an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in .NET APIs where the
 overall operation is qualified by two arguments. For example, 
     Async.BuildPrimitive(arg1,arg2,ws.BeginGetWeather,ws.EndGetWeather)
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.BuildPrimitive``4(``0,``1,``2,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`5{``0,``1,``2,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FastFunc`2{System.IAsyncResult,``3})">
<summary>
 Specify an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in .NET APIs where the
 overall operation is qualified by three arguments. For example, 
     Async.BuildPrimitive(arg1,arg2,arg3,ws.BeginGetWeather,ws.EndGetWeather)
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async.Bind``2(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Control.Async`1{``1}})">

</member>
<member name="T:Microsoft.FSharp.Control.Async">
<summary>
 This static class holds members for creating and manipulating asynchronous computations
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.Zero">
<summary>
 Specify an asynchronous computation that, when run, just returns '()'
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.While(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,System.Boolean},Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit})">
<summary>
 Specify an asynchronous computation that, when run, runs 'p' repeatedly 
 until 'gd()' becomes false.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.Using``2(``0,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Control.Async`1{``1}})">
<summary>
 Specify an asynchronous computation that, when run, runs 'f(resource)'. 
 The action 'resource.Dispose()' is executed as this computation yields its result
 or if the asynchronous computation exits by an exception or by cancellation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.TryWith``1(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.FastFunc`2{System.Exception,Microsoft.FSharp.Control.Async`1{``0}})">
<summary>
 Specify an asynchronous computation that, when run, runs 'p' and returns its result.
 If an exception happens then 'f(exn)' is called and the resulting computation executed instead.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.TryFinally``1(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Specify an asynchronous computation that, when run, runs 'p'. The action 'f' is executed 
 after 'p' completes, whether 'p' exits normally or by an exception. If 'f' raises an exception itself
 the original exception is discarded and the new exception becomes the overall result of the computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.Return``1(``0)">
<summary>
 Specify an asynchronous computation that, when run, returns the result 'v'
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.Let``2(``0,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Control.Async`1{``1}})">
<summary>
 Specify an asynchronous computation that, when run, runs 'f v'
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.For``1(System.Collections.Generic.IEnumerable`1{``0},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit}})">
<summary>
 Specify an asynchronous computation that, when run, enumerates the sequence 'seq'
 on demand and runs 'f' for each element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.Delay``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Control.Async`1{``0}})">
<summary>
 Specify an asynchronous computation that, when run, runs 'f()'
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.Combine``1(Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.Async`1{``0})">
<summary>
 Specify an asynchronous computation that, when run, first runs 'p1' and then runs 'p2', returning the result of 'p2'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder.Bind``2(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Control.Async`1{``1}})">
<summary>
 Specify an asynchronous computation that, when run, runs 'p', and when 
 'p' generates a result 'res', runs 'f res'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncBuilder..ctor">
<summary>
 Generate an object used to build asynchronous computations using F# computation expressions. The value
 'async' is a pre-defined instance of this type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.AsyncBuilder">

</member>
<member name="P:Microsoft.FSharp.Control.AsyncFuture`1.Value">
<summary>
 Wait for the completion of the operation and get its result
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.AsyncFuture`1">
<summary>
 A handle to an asynchronous computation. The Async.AsyncFuture member allows you to 
 spawn a computation and at a later point synchronize on its result.

 Each AsyncFuture object may consume an OS resource in the form of a WaitHandle.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncGroup.TriggerCancel(Microsoft.FSharp.Core.Option`1{System.String})">
<summary>
 Raise the cancellation condition for this group of computations
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncGroup.SpawnFuture``1(Microsoft.FSharp.Control.Async`1{``0})">
<summary>
 Start the asynchronous computation in the .NET thread pool, initially as a CPU-intensive worker item. 
 Return a handle to the computation as an AsyncFuture.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncGroup.Spawn(Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit})">
<summary>
 Start the asynchronous computation in the thread pool. Do not await its result.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncGroup.RunPrimitive``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FastFunc`2{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FastFunc`2{System.OperationCanceledException,Microsoft.FSharp.Core.Unit})">
<summary>
 Start the asynchronous computation in the .NET thread pool, initially as a CPU-intensive worker item. 
 Return a handle to the computation as an AsyncFuture.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncGroup.Run``1(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Boolean})">
<summary>
 Run the asynchronous computation and await its result.

 If an exception occurs in the asynchronous computation then an exception is re-raised by this
 function.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncGroup..ctor">

</member>
<member name="T:Microsoft.FSharp.Control.AsyncGroup">
<summary>
 A handle to a capability to cancel a set of asynchronous computations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncReplyChannel`1.Reply(``0)">

</member>
<member name="T:Microsoft.FSharp.Control.AsyncReplyChannel`1">
<summary>
 A handle to a capability to reply to a PostAndReply message
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.Async`1">
<summary>
 A computation, which, when run, will eventually produce a value of the given type, or else
 raise an exception. The value and/or exception is not returned to the caller immediately, but
 is rather passed to a continuation or exception continuation.

 Async computations are normally specified using the F# 'workflow' syntax for building computations.

 Operationally, async computations typically run partly in the .NET Thread Pool via ThreadPool.QueueUserWorkItem, 
 and, when waiting for asynchronous I/O, they are suspended as thunks using ThreadPool.RegisterWaitForSingleObject,
 waiting for the I/O completion. 

 Some primitive asynchronous computations necessarily end up executing blocking operations:
 these should be run on a pool of threads specifically dedicated to resolving blocking conditions,
 via UnblockedPrimitive. For example, FileOpen on Windows is, by design, a blocking operation.
 However frequently it is important to code as if this is asynchronous. This can be done by running the
 blocking operation via UnblockedPrimitive.

 When run, async computations belong to an AsyncGroup. This can usually be specified when the async computation
 is started. The only action on an AsyncGroup is to raise a cancellation condition for the AsyncGroup.
 Async values check the cancellation condition for their AsyncGroup regularly, though synchronous computations
 within an asynchronous computation will not automatically check this condition. This gives a user-level
 cooperative cancellation protocol.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.DelegateEvent`1.Publish">

</member>
<member name="M:Microsoft.FSharp.Control.DelegateEvent`1.Trigger(System.Object[]`1)">

</member>
<member name="M:Microsoft.FSharp.Control.DelegateEvent`1..ctor">

</member>
<member name="T:Microsoft.FSharp.Control.DelegateEvent`1">

</member>
<member name="P:Microsoft.FSharp.Control.Event`1.Publish">

</member>
<member name="M:Microsoft.FSharp.Control.Event`1.Trigger(``0)">

</member>
<member name="M:Microsoft.FSharp.Control.Event`1..ctor">

</member>
<member name="T:Microsoft.FSharp.Control.Event`1">

</member>
<member name="P:Microsoft.FSharp.Control.Event`2.Publish">

</member>
<member name="M:Microsoft.FSharp.Control.Event`2.Trigger(System.Object,``1)">

</member>
<member name="M:Microsoft.FSharp.Control.Event`2..ctor">

</member>
<member name="T:Microsoft.FSharp.Control.Event`2">

</member>
<member name="M:Microsoft.FSharp.Control.Handler`1.Invoke(System.Object,``0)">

</member>
<member name="T:Microsoft.FSharp.Control.Handler`1">

</member>
<member name="M:Microsoft.FSharp.Control.IDelegateEvent`1.RemoveHandler(``0)">
<summary>
 Remove a listener delegate from an event listener store
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IDelegateEvent`1.AddHandler(``0)">
<summary>
 Connect a handler delegate object to the event.  A handler can
 be later removed using RemoveHandler.  The listener will
 be invoked when the event is fired.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.IDelegateEvent`1">
<summary>
 F# gives special status to non-virtual instance member properties compatible with type IDelegateEvent, 
 generating approriate .NET metadata to make the member appear to other .NET languages as a
 .NET event.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.IEvent`1">
<summary>
 First-class listening points (i.e. objects that permit you to register a 'callback'
 activated when the event is triggered). See the module <c>Event</c>
 for functions to create events.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IEvent`2.Add(Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit})">
<summary>
 Connect a listener function to the event. The listener will
 be invoked when the event is fired.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.IEvent`2">
<summary>
The family of first class event values for delegate types that satisfy the F# delegate constraint.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Lazy`1.Value">
<summary>
 Force the execution of this value and return its result. Same as Value. Mutual exclusion is used to 
 prevent other threads also computing the value.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Lazy`1.IsForced">
<summary>
 Indicates if the lazy value has been successfully computed
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Lazy`1.IsException">
<summary>
 Indicates if the lazy value is being computed or the computation raised an exception
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Lazy`1.IsDelayed">
<summary>
 Indicates if the lazy value has yet to be computed 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy`1.UnsynchronizedForce">
<summary>
 Same as Force, except no lock is taken. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy`1.SynchronizedForce">
<summary>
 Same as Force
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy`1.Force">
<summary>
 Force the execution of this value and return its result. Same as Value. Mutual exclusion is used to 
 prevent other threads also computing the value. If the value is re-forced during its own computation
 the <c>Undefined</c> exception is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy`1.CreateFromValue(``0)">
<summary>
 Create a lazy computation that evaluates to the given value when forced
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy`1.Create(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Create a lazy computation that evaluates to the result of the given function when forced
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.Lazy`1">
<summary>
 The type of delayed computations.
 
 Use the values in the <c>Lazy</c> module to manipulate 
 values of this type, and the notation 'lazy expr' to create values
 of this type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.MailboxProcessor`1.DefaultTimeout(System.Int32)">
<summary>
 Raise a timeout exception if a message not received in this amount of time. Default infinite.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.MailboxProcessor`1.UnsafeMessageQueueContents">

</member>
<member name="P:Microsoft.FSharp.Control.MailboxProcessor`1.DefaultTimeout">
<summary>
 Raise a timeout exception if a message not received in this amount of time. Default infinite.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.TryScan``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Control.Async`1{``1}}},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Return an asynchronous computation which will 
 look through messages in arrival order until 'scanner' returns a Some value. No thread
 is blocked while waiting for further messages. Return None
 if the timeout is exceeded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.TryReceive(Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Return an asynchronous computation which will 
 consume the first message in arrival order. No thread
 is blocked while waiting for further messages. Return None
 if the timeout is exceeded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.TryPostAndReplyAsync``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Control.AsyncReplyChannel`1{``1},``0},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Boolean})">

</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.TryPostAndReply``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Control.AsyncReplyChannel`1{``1},``0},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Boolean})">
<summary>
 Like PostAndReply, but return None if no reply within the timeout period. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.Start(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Control.MailboxProcessor`1{``0},Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Control.AsyncGroup})">
<summary>
 Create and start an instance of a MailboxProcessor. The asynchronous computation executed by the
 processor is the one returned by the 'initial' function. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.Start">
<summary>
 Start the MailboxProcessor
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.Scan``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Control.Async`1{``1}}},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Return an asynchronous computation which will 
 look through messages in arrival order until 'scanner' returns a Some value. No thread
 is blocked while waiting for further messages. Raise a TimeoutException
 if the timeout is exceeded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.Receive(Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Return an asynchronous computation which will 
 consume the first message in arrival order. No thread
 is blocked while waiting for further messages. Raise a TimeoutException
 if the timeout is exceeded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.PostAndReplyAsync``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Control.AsyncReplyChannel`1{``1},``0},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Boolean})">

</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.PostAndReply``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Control.AsyncReplyChannel`1{``1},``0},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Boolean})">
<summary>
 Post a message to the message queue of the MailboxProcessor and await a reply on the channel.
 The message is produced by a single call to the first function which must build a message
 containing the reply channel. The receiving MailboxProcessor must process this message and
 invoke the Reply method on the reply channel precisly once.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.Post(``0)">
<summary>
 Post a message to the message queue of the MailboxProcessor, asynchronously
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.AsyncTryPostAndReply``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Control.AsyncReplyChannel`1{``1},``0},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Boolean})">
<summary>
 Like PostAndReplyAsync, but return None if no reply within the timeout period. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1.AsyncPostAndReply``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Control.AsyncReplyChannel`1{``1},``0},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Boolean})">
<summary>
 Post a message to the message queue of the MailboxProcessor and await a reply on the channel asynchronously.
 The message is produced by a single call to the first function which must build a message
 containing the reply channel. The receiving MailboxProcessor must process this message and
 invoke the Reply method on the reply channel precisly once.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.MailboxProcessor`1..ctor(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Control.MailboxProcessor`1{``0},Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Control.AsyncGroup})">
<summary>
 Create an instance of a MailboxProcessor. The asynchronous computation executed by the
 processor is the one returned by the 'initial' function. This function is not executed until
 'Start' is called.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.MailboxProcessor`1">
<summary>
 A MailboxProcessor is an asynchronous computation that includes the ability to read from a single dedicated
 channel, i.e. a single dedicated message queue. Anyone can send messages to a MailboxProcessor by using the Post method.
 A MailboxProcessor enters a state where it waits for the next message by calling its own Receive or TryReceive method.

 A MailboxProcessor can scan through all available messages using its own Scan or TryScan method, 
 by using a function that selects an asynchronous computation to 
 run based on a scan of the message queue. 

 A MailboxProcessor generally needs to use one or more of its 
 own Receive, TryReceive, Scan or TryScan methods. It also often 
 typically has to allow other asynchronous computations to send 
 messages back to the MailboxProcessor. As a result the creation functions
 are given a reference to the MailboxProcessor itself. 

</summary>
</member>
<member name="T:Microsoft.FSharp.Control.lazy`1">
<summary>
 The type of delayed computations.
 
 Use the values in the <c>Lazy</c> module to manipulate 
 values of this type, and the notation 'lazy expr' to create values
 of this type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.UndefinedException">

</member>
<member name="T:Microsoft.FSharp.Control.CommonExtensions">

</member>
<member name="M:Microsoft.FSharp.Control.Event.choose``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},Microsoft.FSharp.Control.IEvent`2{``2,``0})">
<summary>
 Return a new event which fires on a selection of messages from the original event.
 The selection function takes an original message to an optional new message.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.create``1">
<summary>
 Create an IEvent with no initial listeners. Two items are returned: 
 a function to invoke (trigger) the event, and the event that clients 
 can plug listeners into.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.filter``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Control.IEvent`2{``1,``0})">
<summary>
 Return a new event that listens to the original event and triggers the resulting
 event only when the argument to the event passes the given function
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.listen``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.IEvent`2{``1,``0})">
<summary>
 Run the given function each time the given event is triggered.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.map``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Control.IEvent`2{``2,``0})">
<summary>
 Return a new event that passes values transformed by the given function
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.merge``3(Microsoft.FSharp.Control.IEvent`2{``0,``1},Microsoft.FSharp.Control.IEvent`2{``2,``1})">
<summary>
 Fire the output event when either of the input events fire
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.pairwise``2(Microsoft.FSharp.Control.IEvent`2{``0,``1})">
<summary>
 Return a new event that triggers on the second and subsequent triggerings of the input event.
 The Nth triggering of the input event passes the arguments from the N-1th and Nth triggering as
 a pair. The argument passed to the N-1th triggering is held in hidden internal state until the 
 Nth triggering occurs.

 You should ensure that the contents of the values being sent down the event are
 not mutable. Note that many EventArgs types are mutable, e.g. MouseEventArgs, and
 each firing of an event using this argument type may reuse the same physical 
 argument obejct with different values. In this case you should extract the necessary
 information from the argument before using this combinator.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.partition``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Control.IEvent`2{``1,``0})">
<summary>
 Return a new event that listens to the original event and triggers the 
 first resulting event if the application of the predicate to the event arguments
 returned true, and the second event if it returned false
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.scan``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Control.IEvent`2{``2,``1})">
<summary>
 Return a new event consisting of the results of applying the given accumulating function
 to successive values triggered on the input event.  An item of internal state
 records the current value of the state parameter.  The internal state is not locked during the
 execution of the accumulation function, so care should be taken that the 
 input IEvent not triggered by multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Event.split``4(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Choice`2{``1,``2}},Microsoft.FSharp.Control.IEvent`2{``3,``0})">
<summary>
 Return a new event that listens to the original event and triggers the 
 first resulting event if the application of the function to the event arguments
 returned a Choice2_1, and the second event if it returns a Choice2_2
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.Event">
<summary>
 Basic operations on IEvents.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IEvent.choose``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},Microsoft.FSharp.Control.IEvent`2{``2,``0})">

</member>
<member name="M:Microsoft.FSharp.Control.IEvent.create``1">

</member>
<member name="M:Microsoft.FSharp.Control.IEvent.create1``1">

</member>
<member name="M:Microsoft.FSharp.Control.IEvent.create_DelegateEvent``1">

</member>
<member name="M:Microsoft.FSharp.Control.IEvent.create_HandlerEvent``2">

</member>
<member name="M:Microsoft.FSharp.Control.IEvent.filter``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Control.IEvent`2{``1,``0})">

</member>
<member name="M:Microsoft.FSharp.Control.IEvent.fold``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Control.IEvent`2{``2,``1})">

</member>
<member name="M:Microsoft.FSharp.Control.IEvent.listen``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.IEvent`2{``1,``0})">

</member>
<member name="M:Microsoft.FSharp.Control.IEvent.map``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Control.IEvent`2{``2,``0})">

</member>
<member name="M:Microsoft.FSharp.Control.IEvent.merge``3(Microsoft.FSharp.Control.IEvent`2{``0,``1},Microsoft.FSharp.Control.IEvent`2{``2,``1})">

</member>
<member name="M:Microsoft.FSharp.Control.IEvent.pairwise``2(Microsoft.FSharp.Control.IEvent`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Control.IEvent.partition``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Control.IEvent`2{``1,``0})">

</member>
<member name="M:Microsoft.FSharp.Control.IEvent.split``4(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Choice`2{``1,``2}},Microsoft.FSharp.Control.IEvent`2{``3,``0})">

</member>
<member name="T:Microsoft.FSharp.Control.IEvent">

</member>
<member name="M:Microsoft.FSharp.Core.AbstractClassAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.AbstractClassAttribute">
<summary>
 Adding this attribute to class definition makes it abstract, which means it need not
 implement all its methods. Instances of abstract classes may not be constructed directly.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.AutoOpenAttribute.Path">

</member>
<member name="M:Microsoft.FSharp.Core.AutoOpenAttribute..ctor">
<summary>
 Create an attribute used to mark a module as 'automatically opened' when the enclosing namespace is opened
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AutoOpenAttribute..ctor(System.String)">
<summary>
 Create an attribute used to mark a namespace or module path to be 'automatically opened' when an assembly is referenced
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.AutoOpenAttribute">
<summary>
 This attribute is used for two purposes. When applied to an assembly, it must be given a string
 argument, and this argument must indicate a valid module or namespace in that assembly. Source
 code files compiled with a reference to this assembly are processed in an environment
 where the given path is automatically oepned.

 When applied to a module within an assembly, then the attribute must not be given any arguments.
 When the enclosing namespace is opened in user source code, the module is also implicitly opened.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.AutoSerializableAttribute.Value">

</member>
<member name="M:Microsoft.FSharp.Core.AutoSerializableAttribute..ctor(System.Boolean)">

</member>
<member name="T:Microsoft.FSharp.Core.AutoSerializableAttribute">
<summary>
 Adding this attribute to a type with value 'false' disables the behaviour where F# makes the
 type Serializable by default.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Choice`2">
<summary>
 Helper types for active patterns with 2 choices.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Choice`3">
<summary>
 Helper types for active patterns with 3 choices.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Choice`4">
<summary>
 Helper types for active patterns with 4 choices.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Choice`5">
<summary>
 Helper types for active patterns with 5 choices.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Choice`6">
<summary>
 Helper types for active patterns with 6 choices.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Choice`7">
<summary>
 Helper types for active patterns with 7 choices.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ClassAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.ClassAttribute">
<summary>
 Adding this attribute to a type causes it to be represented using a .NET class.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.VariantNumber">

</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.SourceConstructFlags">

</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.SequenceNumber">

</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute..ctor(Microsoft.FSharp.Core.SourceConstructFlags)">

</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute..ctor(Microsoft.FSharp.Core.SourceConstructFlags,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute..ctor(Microsoft.FSharp.Core.SourceConstructFlags,System.Int32,System.Int32)">

</member>
<member name="T:Microsoft.FSharp.Core.CompilationMappingAttribute">
<summary>
 This attribute is inserted automatically by the F# compiler to tag 
 types and methods in the gneerated .NET code with flags indicating the correspondence with
 original source constructs.  It is used by the functions in the
 Microsoft.FSharp.Reflection library to reverse-map compiled constructs
 to their original forms.  It is not intended for use from use code.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationRepresentationAttribute.Flags">

</member>
<member name="M:Microsoft.FSharp.Core.CompilationRepresentationAttribute..ctor(Microsoft.FSharp.Core.CompilationRepresentationFlags)">

</member>
<member name="T:Microsoft.FSharp.Core.CompilationRepresentationAttribute">
<summary>
 This attribute is used to adjust the runtime representation for a type. 
 For example, it may be used to note that the <c>null</c> representation
 may be used for a type.  This affects how some constructs are compiled.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationRepresentationFlags">

</member>
<member name="P:Microsoft.FSharp.Core.DefaultAugmentationAttribute.Value">

</member>
<member name="M:Microsoft.FSharp.Core.DefaultAugmentationAttribute..ctor(System.Boolean)">

</member>
<member name="T:Microsoft.FSharp.Core.DefaultAugmentationAttribute">
<summary>
 Adding this attribute to a discriminated union with value false
 turns off the generation of standard helper member tester, constructor 
 and accessor members for the generated .NET class for that type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.DefaultValueAttribute.Check">

</member>
<member name="M:Microsoft.FSharp.Core.DefaultValueAttribute..ctor">

</member>
<member name="M:Microsoft.FSharp.Core.DefaultValueAttribute..ctor(System.Boolean)">

</member>
<member name="T:Microsoft.FSharp.Core.DefaultValueAttribute">
<summary>
 Adding this attribute to a field declaration 
 means that the field is not initialized in the turns off the generation of standard helper member tester, constructor 
 and accessor members for the generated .NET class for that type. During 
 type checking constraint is asserted that the field type support 'null'. 
 If the 'check' value is false then the constraint is not asserted. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.EntryPointAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.EntryPointAttribute">
<summary>
 Adding this attribute to a function indicates it is the entrypoint for an application.
 If this absent is not speficied for an EXE then the initialization implicit in the
 module bindings in the last file in the compilation sequence are used as the entrypoint.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.ExperimentalAttribute.Message">

</member>
<member name="M:Microsoft.FSharp.Core.ExperimentalAttribute..ctor(System.String)">

</member>
<member name="T:Microsoft.FSharp.Core.ExperimentalAttribute">
<summary>
 This attribute is used to tag values that are part of an experimental library
 feature
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Release">

</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Minor">

</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Major">

</member>
<member name="M:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute..ctor(System.Int32,System.Int32,System.Int32)">

</member>
<member name="T:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute">
<summary>
 This attribute is added to generated assemblies to indicate the 
 version of the data schema used to encode additional F#
 specific information in the resource attached to compiled F# libraries.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.op_Implicit(Microsoft.FSharp.Core.FastFunc`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.op_Implicit(System.Converter`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.InvokeFast5``4(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,Microsoft.FSharp.Core.FastFunc`2{``3,Microsoft.FSharp.Core.FastFunc`2{``4,``5}}}}},``0,``1,``2,``3,``4)">

</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.InvokeFast4``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,Microsoft.FSharp.Core.FastFunc`2{``3,``4}}}},``0,``1,``2,``3)">

</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.InvokeFast3``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``3}}},``0,``1,``2)">

</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.InvokeFast2``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.Invoke(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.FastFunc`2">
<summary>
 The .NET type used to represent F# function values.  This type is not
 typically used directly, though may be used from other .NET languages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFastFunc``1(System.Action`1{``0})">
<summary>
 Convert the given Action delegate object to an F# function value
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFastFunc``2(System.Converter`2{``0,``1})">
<summary>
 Convert the given Converter delegate object to an F# function value
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 A utility funcion to convert function values from tupled to curried form
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``3(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`2{``0,``1},``2})">
<summary>
 A utility funcion to convert function values from tupled to curried form
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``4(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`3{``0,``1,``2},``3})">
<summary>
 A utility funcion to convert function values from tupled to curried form
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``5(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`4{``0,``1,``2,``3},``4})">
<summary>
 A utility funcion to convert function values from tupled to curried form
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``6(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`5{``0,``1,``2,``3,``4},``5})">
<summary>
 A utility funcion to convert function values from tupled to curried form
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FuncConvert">

</member>
<member name="M:Microsoft.FSharp.Core.GeneralizableValueAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.GeneralizableValueAttribute">
<summary>
 Adding this attribute to a non-function value with generic parameters indicates that 
 uses of the construct can give rise to generic code through type inference. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.IStructuralHash.GetStructuralHashCode(Microsoft.FSharp.Core.byref`1{System.Int32})">

</member>
<member name="T:Microsoft.FSharp.Core.IStructuralHash">

</member>
<member name="M:Microsoft.FSharp.Core.InterfaceAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.InterfaceAttribute">
<summary>
 Adding this attribute to a type causes it to be represented using a .NET interface.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LiteralAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.LiteralAttribute">
<summary>
 Adding this attribute to a value causes it to be compiled as a .NET constant literal.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.MeasureAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.MeasureAttribute">
<summary>
 Adding this attribute to a type causes it to be interpreted as a unit of measure.
 This may only be used under very limited conditions.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NoDynamicInvocationAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.NoDynamicInvocationAttribute">
<summary>
 This attribute is used to tag values that may not be dynamically invoked at runtime. This is
 typically added to inlined functions whose implementations include unverifiable code. It
 causes the method body emitted for the inlined function to raise an exception if 
 dynamically invoked, rather than including the unverifiable code in the generated
 assembly.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.OCamlCompatibilityAttribute.Message">

</member>
<member name="M:Microsoft.FSharp.Core.OCamlCompatibilityAttribute..ctor">

</member>
<member name="M:Microsoft.FSharp.Core.OCamlCompatibilityAttribute..ctor(System.String)">

</member>
<member name="T:Microsoft.FSharp.Core.OCamlCompatibilityAttribute">
<summary>
 This attribute is used to tag values, modules and types that are only
 present in F# to permit a degree of code-compatibility and cross-compilation
 with other implementations of ML-familty languages, in particular OCaml. The
 use of the construct will give a warning unless the --ml-compatibility flag
 is specified.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Option`1.Value">
<summary>
 Get the value of a 'Some' option. A NullReferenceException is raised if the option is 'None'.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Option`1.None">
<summary>
 Create an option value that is a 'None' value.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Option`1.Item">

</member>
<member name="P:Microsoft.FSharp.Core.Option`1.IsSome">
<summary>
 Return 'true' if the option is a 'Some' value.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Option`1.IsNone">
<summary>
 Return 'true' if the option is a 'None' value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option`1.Some(``0)">
<summary>
 Create an option value that is a 'Some' value.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Option`1">
 <summary>
 The type of optional values.  When used from other .NET languages the
 empty option is the <c>null</c> value.  

 Use the constructors <c>Some</c> and <c>None</c> to create values of this type.
 Use the values in the <c>Option</c> module to manipulate values of this type,
 or pattern match against the values directly.
 </summary>

 <note><c>None</c> values will appear as the value <c>null</c> to other .NET languages.
 Instance methods on this type will appear as static methods to other .NET languages
 due to the use of <c>null</c> as a value representation.
 </note>
</member>
<member name="M:Microsoft.FSharp.Core.OptionalArgumentAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.OptionalArgumentAttribute">
<summary>
 This attribute is added automatically for all optional arguments
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.OverloadIDAttribute.UniqueName">
<summary>
 A unique identifier for this overloaded member within a given overload set
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OverloadIDAttribute..ctor(System.String)">

</member>
<member name="T:Microsoft.FSharp.Core.OverloadIDAttribute">
<summary>
 Adding the OverloadID attribute to a member permits it to
 be part of a group overloaded by the same name and arity.  The string
 must be a unique name amongst those in the overload set.  Overrides
 of this method, if permitted, must be given the same OverloadID,
 and the OverloadID must be specified in both signature and implementation
 files if signature files are used.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Ref`1.Value(``0)">
<summary>
 The current value of the reference cell
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Ref`1.Value">
<summary>
 The current value of the reference cell
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Ref`1">
<summary>
 The type of mutable references.  Use the functions [:=] and [!] to get and
 set values of this type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.ReferenceEqualityAttribute.Value">

</member>
<member name="M:Microsoft.FSharp.Core.ReferenceEqualityAttribute..ctor">

</member>
<member name="M:Microsoft.FSharp.Core.ReferenceEqualityAttribute..ctor(System.Boolean)">

</member>
<member name="T:Microsoft.FSharp.Core.ReferenceEqualityAttribute">
<summary>
 Adding this attribute to a record or union type disables the automatic generation
 of overrides for 'System.Object.Equals(obj)', 'System.Object.GetHashCode()' 
 and 'System.IComparable' for the type. The type will by default use reference equality.
 This is identical to adding attributes StructuralEquality(false) and StructuralComparison(false).
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ReflectedDefinitionAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.ReflectedDefinitionAttribute">
<summary>
 Adding this attribute to the let-binding for the definition of a top-level 
 value makes the quotation expression that implements the value available
 for use at runtime.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.RequiresExplicitTypeArgumentsAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.RequiresExplicitTypeArgumentsAttribute">
<summary>
 Adding this attribute to a type, value or member requires that 
 uses of the construct must explicitly instantiate any generic type parameters.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SealedAttribute.Value">

</member>
<member name="M:Microsoft.FSharp.Core.SealedAttribute..ctor">

</member>
<member name="M:Microsoft.FSharp.Core.SealedAttribute..ctor(System.Boolean)">

</member>
<member name="T:Microsoft.FSharp.Core.SealedAttribute">
<summary>
 Adding this attribute to class definition makes it sealed, which means it may not
 be extended or implemented.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.SourceConstructFlags">

</member>
<member name="M:Microsoft.FSharp.Core.StructAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.StructAttribute">
<summary>
 Adding this attribute to a type causes it to be represented using a .NET struct.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.StructuralComparisonAttribute.Value">

</member>
<member name="M:Microsoft.FSharp.Core.StructuralComparisonAttribute..ctor">

</member>
<member name="M:Microsoft.FSharp.Core.StructuralComparisonAttribute..ctor(System.Boolean)">

</member>
<member name="T:Microsoft.FSharp.Core.StructuralComparisonAttribute">
<summary>
 Adding this attribute to a record, union or struct type with value 'false' disables the automatic generation
 of implementations for 'System.IComparable' for the type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.StructuralEqualityAttribute.Value">

</member>
<member name="M:Microsoft.FSharp.Core.StructuralEqualityAttribute..ctor">

</member>
<member name="M:Microsoft.FSharp.Core.StructuralEqualityAttribute..ctor(System.Boolean)">

</member>
<member name="T:Microsoft.FSharp.Core.StructuralEqualityAttribute">
<summary>
 Adding this attribute to a record, union or struct type with value 'false' 
 confirms the automatic generation of overrides for 'System.Object.Equals(obj)' 
 and 'System.Object.GetHashCode()' for the type. This attribute is usually used in 
 conjunction with StructuralComparison(false) to generate a type that supports
 structural equality but not structural comparison.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.TupleEnd`1">
<summary>
 Indicates the end of a Tuple type
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.TupleNested`1">
<summary>
 Indicates that a Tuple tuple continues beyond length 6
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Tuple`2">
<summary>
 Compiled versions of F# tuple types.  These are not used directly, though
 these compiled forms are seen by other .NET languages.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Tuple`3">
<summary>
 Compiled versions of F# tuple types.  These are not used directly, though
 these compiled forms are seen by other .NET languages.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Tuple`4">
<summary>
 Compiled versions of F# tuple types.  These are not used directly, though
 these compiled forms are seen by other .NET languages.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Tuple`5">
<summary>
 Compiled versions of F# tuple types.  These are not used directly, though
 these compiled forms are seen by other .NET languages.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Tuple`6">
<summary>
 Compiled versions of F# tuple types.  These are not used directly, though
 these compiled forms are seen by other .NET languages.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Tuple`7">
<summary>
 Compiled versions of F# tuple types.  These are not used directly, though
 these compiled forms are seen by other .NET languages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.TypeFunc.Specialize``1">

</member>
<member name="M:Microsoft.FSharp.Core.TypeFunc..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.TypeFunc">
<summary>
 The .NET type used to represent F# first-class type function values.  This type is not
 typically used directly.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Unit">
<summary>
 The type 'unit', which has only one value "()". This value is special and
 always uses the representation 'null'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.UnverifiableAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.UnverifiableAttribute">
<summary>
 This attribute is used to tag values whose use will result in the generation
 of unverifiable code. These values are inevitably marked 'inline' to ensure that
 the unverifiable constructs are not present in the actual code for the F# library,
 but are rather copied to the source code of the caller.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[,,,]`1">
<summary>
 Four dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[,,]`1">
<summary>
 Three dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[,]`1">
<summary>
 Two dimensional arrays, typically zero-based. 

 Use the values in the <c>Array2</c> module
 to manipulate values of this type, or the notation 'arr.[x,y]' to get/set array
 values.   

 Non-zero-based arrays can also be created using methods on the System.Array type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[]`1">
<summary>
 Single dimensional, zero-based arrays, written 'int[]', 'string[]' etc.
 Use the values in the <c>Array</c> module to manipulate values 
 of this type, or the notation 'arr.[x]' to get/set array
 values.   
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.array`1">
<summary>
 Single dimensional, zero-based arrays, written 'int[]', 'string[]' etc.
 Use the values in the <c>Array</c> module to manipulate values 
 of this type, or the notation 'arr.[x]' to get/set array
 values.   
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.bigint">

</member>
<member name="T:Microsoft.FSharp.Core.bignum">

</member>
<member name="T:Microsoft.FSharp.Core.bool">

</member>
<member name="T:Microsoft.FSharp.Core.byref`1">
<summary>
 The type for by-reference, stack-allocated argument passing.  It is used
 by .NET assemblies and by the type <c>IStructuralHash</c> to
 pass the hash-node-count around.  Use of this type in F# code may result in
 unverifiable code being generated.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.byte">

</member>
<member name="T:Microsoft.FSharp.Core.char">

</member>
<member name="T:Microsoft.FSharp.Core.decimal">

</member>
<member name="T:Microsoft.FSharp.Core.decimal`1">

</member>
<member name="T:Microsoft.FSharp.Core.double">

</member>
<member name="T:Microsoft.FSharp.Core.exn">

</member>
<member name="T:Microsoft.FSharp.Core.float">

</member>
<member name="T:Microsoft.FSharp.Core.float32">

</member>
<member name="T:Microsoft.FSharp.Core.float32`1">

</member>
<member name="T:Microsoft.FSharp.Core.float`1">

</member>
<member name="T:Microsoft.FSharp.Core.ilsigptr`1">
<summary>
 This type is for internal use by the F# code generator
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int">

</member>
<member name="T:Microsoft.FSharp.Core.int16">

</member>
<member name="T:Microsoft.FSharp.Core.int32">

</member>
<member name="T:Microsoft.FSharp.Core.int64">

</member>
<member name="T:Microsoft.FSharp.Core.int8">

</member>
<member name="T:Microsoft.FSharp.Core.nativeint">

</member>
<member name="T:Microsoft.FSharp.Core.nativeptr`1">
<summary>
 The type of machine pointers assumed to be pointing to 
 unmanaged or pinned memory containing values or an array of
 values of the given type.

 This type should only be used when writing F# code that interoperates
 with C code.  Use of this type in F# code may result in
 unverifiable code being generated.  Conversions to and from the 
 <c>nativeint</c> type may be required. Values of this type can be generated
 by the functions in the NativeInterop.NativePtr module.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.obj">

</member>
<member name="T:Microsoft.FSharp.Core.option`1">
 <summary>
 The type of optional values.  When used from other .NET languages the
 empty option is the <c>null</c> value.  

 Use the constructors <c>Some</c> and <c>None</c> to create values of this type.
 Use the values in the <c>Option</c> module to manipulate values of this type,
 or pattern match against the values directly.
 </summary>

 <note>'None' values will appear as the value <c>null</c> to other .NET languages.
 Instance methods on this type will appear as static methods to other .NET languages
 due to the use of <c>null</c> as a value representation.
 </note>
</member>
<member name="T:Microsoft.FSharp.Core.ref`1">
<summary>
 The type of mutable references.  Use the functions [:=] and [!] to get and
 set values of this type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.sbyte">

</member>
<member name="T:Microsoft.FSharp.Core.seq`1">

</member>
<member name="T:Microsoft.FSharp.Core.single">

</member>
<member name="T:Microsoft.FSharp.Core.string">

</member>
<member name="T:Microsoft.FSharp.Core.uint16">

</member>
<member name="T:Microsoft.FSharp.Core.uint32">

</member>
<member name="T:Microsoft.FSharp.Core.uint64">

</member>
<member name="T:Microsoft.FSharp.Core.uint8">

</member>
<member name="T:Microsoft.FSharp.Core.unativeint">

</member>
<member name="T:Microsoft.FSharp.Core.unit">
<summary>
 The type 'unit', which has only one value "()". This value is special and
 always uses the representation 'null'.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.AssertionFailureException">
<summary>
 This exception is raised as the final result of the syntactic expression 'assert(false)'
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.DynamicInvocationNotSupportedException">
<summary>
 Dynamic invocations of functions marked with the NoDynamicInvocationAttribute attribute raise this exception
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FailureException">
<summary>
 This exception is raised by 'failwith'
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.MatchFailureException">
<summary>
 Non-exhaustive match failures will raise the MatchFailure exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.AdditionDynamic``3(``0,``1)">
<summary>
 A compiler intrinsic that implements dynamic invocations to the '+' operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.CheckedAdditionDynamic``3(``0,``1)">
<summary>
 A compiler intrinsic that implements dynamic invocations to the checked '+' operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DefaultValue``1">
<summary>
 Generate a null value for reference types.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DivideByInt``1(``0,System.Int32)">
<summary>
 Divide a floating point value by an integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DivideByIntDynamic``1(``0,System.Int32)">
<summary>
 A compiler intrinsic that implements dynamic invocations for the DivideByInt primitive
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.EnumOfValue``2(``0)">
<summary>
 Build an enum value from an underlying value
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.EnumToValue``2(``0)">
<summary>
 Get the underlying value for an enum value
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericComparison``1(``0,``0)">
<summary>
 Compare two values 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericComparisonBiModal``1(``0,``0)">
<summary>
 Compare two values. May be called as a recursive case from an implementation of System.IComparable to
 ensure consistent NaN comparison semantics.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericEquality``1(``0,``0)">
<summary>
 Compare two values for equality
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericGreaterOrEqual``1(``0,``0)">
<summary>
 Compare two values   
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericGreaterThan``1(``0,``0)">
<summary>
 Compare two values   
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericHash``1(``0)">
<summary>
 Hash a value according to its structure.  See the IStructuralHash interface.
 Implementations of IStructuralHash for aggregate structured data structures
 should call this function to hash sub-structures.

 The byref argument points to a count of the
 number of significant nodes remaining to be hashed in the cooperative hash.
 Substructures and leaf nodes (such as integers) should be hashed by calling 
 Microsoft.FSharp.Core.LanguagePrimitives.GenericHashParam, but only if the hash count
 is non-zero.  If the hash count is zero GenericHashParam must not be called.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericHashParam``1(``0,Microsoft.FSharp.Core.byref`1{System.Int32})">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericInequality``1(``0,``0)">
<summary>
 Compare two values for disequality
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericLessOrEqual``1(``0,``0)">
<summary>
 Compare two values   
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericLessThan``1(``0,``0)">
<summary>
 Compare two values   
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericMaximum``1(``0,``0)">
<summary>
 Take the maximum of two values structurally according to the order given by GenericComparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericMinimum``1(``0,``0)">
<summary>
 Take the minimum of two values structurally according to the order given by GenericComparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericOne``1">
<summary>
 Resolves to the one value for any primitive numeric type or any type with a static member called 'One'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericOneDynamic``1">
<summary>
 Resolves to the zero value for any primitive numeric type or any type with a static member called 'Zero'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericZero``1">
<summary>
 Resolves to the zero value for any primitive numeric type or any type with a static member called 'Zero'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericZeroDynamic``1">
<summary>
 Resolves to the zero value for any primitive numeric type or any type with a static member called 'Zero'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseInt32(System.String)">
<summary>
 Parse an int32 according to the rules used by the overloaded 'int32' conversion operator when applied to strings
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseInt64(System.String)">
<summary>
 Parse an int64 according to the rules used by the overloaded 'int64' conversion operator when applied to strings
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseUInt32(System.String)">
<summary>
 Parse an uint32 according to the rules used by the overloaded 'uint32' conversion operator when applied to strings
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseUInt64(System.String)">
<summary>
 Parse an uint64 according to the rules used by the overloaded 'uint64' conversion operator when applied to strings
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.PhysicalEquality``1(``0,``0)">
<summary>
 Reference/physical equality. 
 True if boxed versions of the inputs are reference-equal, OR if
 both are primitive numeric types and the implementation of Object.Equals for the type
 of the first argument returns true on the boxed versions of the inputs.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.PhysicalHash``1(``0)">
<summary>
 The physical hash.  Hashes on the object identity, except for value types,
 where we hash on the contents.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.PhysicalInequality``1(``0,``0)">
<summary>
 Reference/physical disequality (not equals)
 False if boxed versions of the inputs are reference-equal, OR if
 both are primitive numeric types and the implementation of Object.Equals for the type
 of the first argument returns true on the boxed versions of the inputs.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralComparison``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralEquality``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralGreaterOrEqual``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralGreaterThan``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralHash``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralHashParam``1(``0,Microsoft.FSharp.Core.byref`1{System.Int32})">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralInequality``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralLessOrEqual``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralLessThan``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralMaximum``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralMinimum``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericComparisonIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericComparisonIntrinsicBiModal``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericEqualityIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericGreaterOrEqualIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericGreaterThanIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericHashParamIntrinsic``1(``0,Microsoft.FSharp.Core.byref`1{System.Int32})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericLessOrEqualIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericLessThanIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.PhysicalEqualityIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.PhysicalHashIntrinsic``1(``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.ArrayGet``1(``0[]`1,System.Int32)">
<summary>
 Primitive used by pattern match compilation 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.CreateInstance``1">
<summary>
 This function implements calls to default constructors
 acccessed by 'new' constraints.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.MakeDecimal(System.Int32,System.Int32,System.Int32,System.Boolean,System.Byte)">
<summary>
 This function implements parsing of decimal constants
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.TypeTestFast``1(System.Object)">
<summary>
 A compiler intrinsic that implements the ':?' operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.TypeTestGeneric``1(System.Object)">
<summary>
 A compiler intrinsic that implements the ':?' operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.UnboxFast``1(System.Object)">
<summary>
 A compiler intrinsic that implements the ':?>' operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.UnboxGeneric``1(System.Object)">
<summary>
 A compiler intrinsic that implements the ':?>' operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.op_IndexedAssign``3(``0,``1,``2)">
<summary>
 The standard overloaded associative (indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.op_IndexedAssign2``4(``0,``1,``2,``3)">
<summary>
 The standard overloaded associative (2-indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.op_IndexedAssign3``5(``0,``1,``2,``3,``4)">
<summary>
 The standard overloaded associative (3-indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.op_IndexedLookup``3(``0,``1)">
<summary>
 The standard overloaded associative (indexed) lookup operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.op_IndexedLookup2``4(``0,``1,``2)">
<summary>
 The standard overloaded associative (2-indexed) lookup operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.op_IndexedLookup3``5(``0,``1,``2,``3)">
<summary>
 The standard overloaded associative (3-indexed) lookup operator
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_Amp(System.Boolean,System.Boolean)">
<summary>
 Binary 'and'.  When used as a binary operator the right hand value is evaluated only on demand
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_AmpAmp(System.Boolean,System.Boolean)">
<summary>
 Binary 'and'.  When used as a binary operator the right hand value is evaluated only on demand
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_BarBar(System.Boolean,System.Boolean)">
<summary>
 Binary 'or'.  When used as a binary operator the right hand value is evaluated only on demand
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_TwiddleAmp``1(``0)">
<summary>
 Address-of. Uses of this value may result in the generation of unverifiable code.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_TwiddleAmpAmp``1(``0)">
<summary>
 Address-of. Uses of this value may result in the generation of unverifiable code.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.or(System.Boolean,System.Boolean)">
<summary>
 Binary 'or'.  When used as a binary operator the right hand value is evaluated only on demand
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators">
<summary>
 Compiler-recognized operators
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives">

</member>
<member name="T:Microsoft.FSharp.Core.Operators.InvalidArgumentException">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.InvalidArgument(System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.abs``1(``0)">
<summary>
 Absolute value of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.acos``1(``0)">
<summary>
 Inverse cosine of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.asin``1(``0)">
<summary>
 Inverse sine of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.assert(System.Boolean)">
<summary>
 Call <c>System.Diagnostics.Debug.Assert(condition)</c>. Calls to this function are generated when <c>assert</c> is used as a first class function value
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.atan``1(``0)">
<summary>
 Inverse tangent of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.atan2``2(``0,``0)">
<summary>
 Inverse tangent of <c>x/y</c> where <c>x</c> and <c>y</c> are specified separately
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.box``1(``0)">
<summary>
 Boxes a strongly typed value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.byte``1(``0)">
<summary>
 Converts the argument to byte. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Byte.Parse()</c> on strings and otherwise requires a <c>ToByte</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ceil``1(``0)">
<summary>
 Ceiling of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.char``1(``0)">
<summary>
 Converts the argument to character. Numeric inputs are converted according to the UTF-16 
 encoding for characters. String inputs must be exactly one character long.
 For other types a static member ToChar must exist on the type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.compare``1(``0,``0)">
<summary>
 Generic comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.cos``1(``0)">
<summary>
 Cosine of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.cosh``1(``0)">
<summary>
 Hyperbolic cosine  of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.decimal``1(``0)">
<summary>
 Converts the argument to System.Decimal using a direct conversion for all 
 primitive numeric types and requiring a <c>ToDecimal</c> method otherwise
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.decr(Microsoft.FSharp.Core.Ref`1{System.Int32})">
<summary>
 Decrement a mutable reference cell containing an integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.defaultArg``1(Microsoft.FSharp.Core.Option`1{``0},``0)">
<summary>
 Used to specify a default value for an optional argument in the implementation of a function
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.double``1(``0)">
<summary>
 Converts the argument to 64-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Double.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToDouble</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.enum``1(System.Int32)">
<summary>
 Converts the argument to a particular enum type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.exit``1(System.Int32)">
<summary>
 Exit the current hardware isolated process, if security settings permit,
 otherwise raise an exception.  Calls <c>System.Environment.Exit</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.exp``1(``0)">
<summary>
 Exponential of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.failwith``1(System.String)">
<summary>
 Throw a <c>FailureException</c> exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.float``1(``0)">
<summary>
 Converts the argument to 64-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Double.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToDouble</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.float32``1(``0)">
<summary>
 Converts the argument to 32-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Single.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToSingle</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.floor``1(``0)">
<summary>
 Floor of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.fst``2(Microsoft.FSharp.Core.Tuple`2{``0,``1})">
<summary>
 Return the first element of a tuple, <c>fst (a,b) = a</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.hash``1(``0)">
<summary>
 The "hash" function is a structural hash function.  It is 
 designed to return equal hash values for items that are 
 equal according to the standard "=" operator. The exact
 behaviour of the function can be adjusted on a type-by-type
 basis by implementing GetHashCode and/or the IStructuralHash interface for each type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.id``1(``0)">
<summary>
 The identity function
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ignore``1(``0)">
<summary>
 Ignore the passed value. This is often used to throw away results of a computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.incr(Microsoft.FSharp.Core.Ref`1{System.Int32})">
<summary>
 Increment a mutable reference cell containing an integer
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.infinity">
<summary>
 Equivalent to <c>System.Double.PositiveInfinity</c>
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.infinityf">
<summary>
 Equivalent to <c>System.Single.PositiveInfinity</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.int``1(``0)">
<summary>
 Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int32.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToInt32</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.int16``1(``0)">
<summary>
 Converts the argument to signed 16-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int16.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToInt16</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.int32``1(``0)">
<summary>
 Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int32.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToInt32</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.int64``1(``0)">
<summary>
 Converts the argument to signed 64-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int64.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToInt64</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.invalid_arg``1(System.String)">
<summary>
 Throw an <c>ArgumentException</c> exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.invalid_op``1(System.String)">
<summary>
 Throw an <c>InvalidOperationException</c> exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.lock``2(``0,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``1})">
<summary>
 Execute the function as a mutual-exlcusion region using the input value as a lock. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.log``1(``0)">
<summary>
 Natural logarithm of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.log10``1(``0)">
<summary>
 Logarithm to base 10 of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.max``1(``0,``0)">
<summary>
 Maximum based on generic comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.min``1(``0,``0)">
<summary>
 Minimum based on generic comparison
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.nan">
<summary>
 Equivalent to <c>System.Double.NaN</c>
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.nanf">
<summary>
 Equivalent to <c>System.Single.NaN</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.nativeint``1(``0)">
<summary>
 Converts the argument to signed native integer. This is a direct conversion for all 
 primitive numeric types and <c>ToIntPtr</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.not(System.Boolean)">
<summary>
 Negate a logical value. <c>not true</c> equals <c>false</c> and <c>not false</c> equals <c>true</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.not_found``1">
<summary>
 Throw an <c>KeyNotFoundException</c> exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Addition``3(``0,``1)">
<summary>
 Overloaded addition operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Append``1(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Concatenate two lists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_BitwiseAnd``1(``0,``0)">
<summary>
 Overloaded logical-AND operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_BitwiseOr``1(``0,``0)">
<summary>
 Overloaded logical-OR operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ColonEquals``1(Microsoft.FSharp.Core.Ref`1{``0},``0)">
<summary>
 Assign to a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ComposeLeft``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Core.FastFunc`2{``2,``0})">
<summary>
 Compose two functions, the function on the right being applied first
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ComposeRight``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Core.FastFunc`2{``1,``2})">
<summary>
 Compose two functions, the function on the left being applied first
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Concatenate(System.String,System.String)">
<summary>
 Concatenate two strings.  The overlaoded operator '+' may also be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Dereference``1(Microsoft.FSharp.Core.Ref`1{``0})">
<summary>
 Dereference a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Division``3(``0,``1)">
<summary>
 Overloaded division operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Equality``1(``0,``0)">
<summary>
Structural equality
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ExclusiveOr``1(``0,``0)">
<summary>
 Overloaded logical-XOR operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Exponentiation``1(``0,``0)">
<summary>
 Overloaded power operator.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_GreaterThan``1(``0,``0)">
<summary>
 Structural greater-than
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_GreaterThanOrEqual``1(``0,``0)">
<summary>
Structural greater-than-or-equal
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_IndexedAssign``3(``0,``1,``2)">
<summary>
 The standard overloaded associative (indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_IndexedAssign2``4(``0,``1,``2,``3)">
<summary>
 The standard overloaded associative (2-indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_IndexedAssign3``5(``0,``1,``2,``3,``4)">
<summary>
 The standard overloaded associative (3-indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_IndexedLookup``3(``0,``1)">
<summary>
 The standard overloaded associative (indexed) lookup operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_IndexedLookup2``4(``0,``1,``2)">
<summary>
 The standard overloaded associative (2-indexed) lookup operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_IndexedLookup3``5(``0,``1,``2,``3)">
<summary>
 The standard overloaded associative (3-indexed) lookup operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LeftShift``1(``0,System.Int32)">
<summary>
 Overloaded byte-shift left operator by a specified number of bits
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessGreater``1(``0,``0)">
<summary>
Structural inequality
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessThan``1(``0,``0)">
<summary>
 Structural less-than comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessThanOrEqual``1(``0,``0)">
<summary>
Structural less-than-or-equal comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LogicalNot``1(``0)">
<summary>
 Overloaded logical-NOT operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Modulus``3(``0,``1)">
<summary>
 Overloaded modulo operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Multiply``3(``0,``1)">
<summary>
 Overloaded multiplication operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeLeft``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0)">
<summary>
 Apply a function to a value, the value being on the right, the function on the left
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeRight``2(``0,Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 Apply a function to a value, the value being on the left, the function on the right
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Range``1(``0,``0)">
<summary>
 The standard overloaded range operator, e.g. <c>[n..m]</c> for lists, <c>seq {n..m}</c> for sequences
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_RangeStep``1(``0,``0,``0)">
<summary>
 The standard overloaded skip range operator, e.g. <c>[n..skip..m]</c> for lists, <c>seq {n..skip..m}</c> for sequences
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_RightShift``1(``0,System.Int32)">
<summary>
 Overloaded byte-shift right operator by a specified number of bits
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Subtraction``3(``0,``1)">
<summary>
 Overloaded subtraction operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_UnaryNegation``1(``0)">
<summary>
 Overloaded unary negation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_UnaryPlus``1(``0)">
<summary>
 Overloaded prefix=plus operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.pown``1(``0,System.Int32)">
<summary>
 Overloaded power operator. If <c>n > 0</c> then equivalent to <c>x*...*x</c> for <c>n</c> occurrences of <c>x</c>. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.raise``1(System.Exception)">
<summary>
 Raises an exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ref``1(``0)">
<summary>
 Create a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.rethrow``1">
<summary>
 Rethrows an exception. This should only be used when handling an exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.round``1(``0)">
<summary>
 Round the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.sbyte``1(``0)">
<summary>
 Converts the argument to signed byte. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>SByte.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToSByte</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.sign``1(``0)">
<summary>
 Sign of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.sin``1(``0)">
<summary>
 Sine of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.single``1(``0)">
<summary>
 Converts the argument to 32-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Single.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToSingle</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.sinh``1(``0)">
<summary>
 Hyperbolic sine of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.sizeof``1">
<summary>
 Returns the internal size of a type in bytes. For example, <c>sizeof&lt;int&gt;</c> returns 4.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.snd``2(Microsoft.FSharp.Core.Tuple`2{``0,``1})">
<summary>
 Return the second element of a tuple, <c>snd (a,b) = b</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.sqrt``2(``0)">
<summary>
 Square root of the given number
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.stderr">
<summary>
 Returns the value of the property <c>System.Console.Error</c>. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.stdin">
<summary>
 Returns the value of the property <c>System.Console.In</c>. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.stdout">
<summary>
 Returns the value of the property <c>System.Console.Out</c>. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.string``1(``0)">
<summary>
 Converts the argument to a string using <c>ToString</c>.
 For standard integer and floating point values the <c>ToString</c> conversion uses <c>CultureInfo.InvariantCulture</c>.
 Note, native integer <c>ToString</c> does not support specifying <c>CultureInfo</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.tan``1(``0)">
<summary>
 Tangent of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.tanh``1(``0)">
<summary>
 Hyperbolic tangent of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.truncate``1(``0)">
<summary>
 Overloaded truncate operator.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.typedefof``1">
<summary>
 Generate a System.Type representation for a type definition. If the
 input type is a generic type instantiation then return the 
 generic type definition associated with all such instantiations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.typeof``1">
<summary>
 Generate a System.Type runtime represenation of a static type.
 The static type is still maintained on the value returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.uint16``1(``0)">
<summary>
 Converts the argument to unsigned 16-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt16.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToUInt16</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.uint32``1(``0)">
<summary>
 Converts the argument to unsigned 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt32.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToUInt32</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.uint64``1(``0)">
<summary>
 Converts the argument to unsigned 64-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt64.Parse()</c>  with InvariantCulture settings. Otherwise the operation requires and invokes a <c>ToUInt64</c> method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.unativeint``1(``0)">
<summary>
 Converts the argument to unsigned native integer using a direct conversion for all 
 primitive numeric types and requiring a <c>ToUintPtr</c> method otherwise
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.unbox``1(System.Object)">
<summary>
 Unboxes a strongly typed value. This is the inverse of <c>box</c>, unbox&lt;t&gt;(box&lt;t&gt; a) equals a.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.using``2(``0,Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 Clean up resources associated with the input object after the completion of the given function.
 Cleanup occurs even when an exception is raised by the protected
 code. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.|InvalidArgument|_|(System.Exception)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.|KeyValue|``2(System.Collections.Generic.KeyValuePair`2{``0,``1})">
<summary>
 An active pattern to match values of type <c>System.Collections.Generic.KeyValuePair</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.byte``1(``0)">
<summary>
 Converts the argument to byte. This is a direct conversion for all 
 primitive numeric types and <c>ToByte</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.char``1(``0)">
<summary>
 Converts the argument to unicode character based on UTF16 encoding (a direct conversion for all 
 primitive numeric types and <c>ToUIntPtr</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.int``1(``0)">
<summary>
 Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types and <c>ToInt32</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.int16``1(``0)">
<summary>
 Converts the argument to signed 16-bit integer. This is a direct conversion for all 
 primitive numeric types and <c>ToInt16</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.int32``1(``0)">
<summary>
 Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types and <c>ToInt32</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.int64``1(``0)">
<summary>
 Converts the argument to signed 64-bit integer. This is a direct conversion for all 
 primitive numeric types and <c>ToInt64</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.nativeint``1(``0)">
<summary>
 Converts the argument to signed native integer. This is a direct conversion for all 
 primitive numeric types and <c>ToIntPtr</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Addition``3(``0,``1)">
<summary>
 Overloaded addition operator (checks for overflow)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Multiply``3(``0,``1)">
<summary>
 Overloaded multiplication operator (checks for overflow)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Subtraction``3(``0,``1)">
<summary>
 Overloaded subtraction operator (checks for overflow)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_UnaryNegation``1(``0)">
<summary>
 Overloaded unary negation (checks for overflow)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.sbyte``1(``0)">
<summary>
 Converts the argument to signed byte. This is a direct conversion for all 
 primitive numeric types and <c>ToSByte</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.uint16``1(``0)">
<summary>
 Converts the argument to unsigned 16-bit integer. This is a direct conversion for all 
 primitive numeric types and <c>ToUInt16</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.uint32``1(``0)">
<summary>
 Converts the argument to unsigned 32-bit integer. This is a direct conversion for all 
 primitive numeric types and <c>ToUInt32</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.uint64``1(``0)">
<summary>
 Converts the argument to unsigned 64-bit integer. This is a direct conversion for all 
 primitive numeric types and <c>ToUInt64</c> method otherwise)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.unativeint``1(``0)">
<summary>
 Converts the argument to unsigned native integer. This is a direct conversion for all 
 primitive numeric types and <c>ToUIntPtr</c> method otherwise)
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.Checked">
<summary>
 This module contains the basic arithmetic operations with overflow checks.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedFunctions.pown(System.Int32,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'int32'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedFunctions.powndf(System.Double,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'float'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedFunctions.pownf(System.Single,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'float32'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedFunctions.powng``1(``0,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``0,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedFunctions.pownl(System.Int64,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'int64'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedFunctions.pownm(System.Decimal,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'decimal'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedFunctions.pownn(System.IntPtr,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'nativeint'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedFunctions.powns(System.Int16,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'int16'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedFunctions.pownu(System.UInt32,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'uint32'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedFunctions.pownul(System.UInt64,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'uint64'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedFunctions.pownun(System.UIntPtr,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'unativeint'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedFunctions.pownus(System.UInt16,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'uint16'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedFunctions.pownuy(System.Byte,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'byte'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedFunctions.powny(System.SByte,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic 'pown' operator on values of type 'sbyte'
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.OptimizedFunctions">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.AbsDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.AcosDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.AsinDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.Atan2Dynamic``2(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.AtanDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.CeilingDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.CosDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.CoshDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.ExpDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.FloorDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.GetArraySlice``1(``0[]`1,Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32})">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.GetArraySlice2D``1(``0[,]`1,Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32})">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.GetStringSlice(System.String,Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32})">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.Log10Dynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.LogDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.PowDynamic``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.RangeByte(System.Byte,System.Byte,System.Byte)">
<summary>
 Generate a range of byte values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.RangeChar(System.Char,System.Char)">
<summary>
 Generate a range of char values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.RangeDouble(System.Double,System.Double,System.Double)">
<summary>
 Generate a range of float values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.RangeDynamic``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.RangeGeneric``1(``0,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``0,``0,``0)">
<summary>
 Generate a range of values using the given zero, add, start, step and stop values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.RangeInt16(System.Int16,System.Int16,System.Int16)">
<summary>
 Generate a range of int16 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.RangeInt32(System.Int32,System.Int32,System.Int32)">
<summary>
 Generate a range of integers  
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.RangeInt64(System.Int64,System.Int64,System.Int64)">
<summary>
 Generate a range of int64 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.RangeIntPtr(System.IntPtr,System.IntPtr,System.IntPtr)">
<summary>
 Generate a range of nativeint values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.RangeSByte(System.SByte,System.SByte,System.SByte)">
<summary>
 Generate a range of sbyte values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.RangeSingle(System.Single,System.Single,System.Single)">
<summary>
 Generate a range of float32 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.RangeStepDynamic``1(``0,``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.RangeUInt16(System.UInt16,System.UInt16,System.UInt16)">
<summary>
 Generate a range of uint16 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.RangeUInt32(System.UInt32,System.UInt32,System.UInt32)">
<summary>
 Generate a range of uint32 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.RangeUInt64(System.UInt64,System.UInt64,System.UInt64)">
<summary>
 Generate a range of uint64 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.RangeUIntPtr(System.UIntPtr,System.UIntPtr,System.UIntPtr)">
<summary>
 Generate a range of unativeint values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.RoundDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.SetArraySlice``1(``0[]`1,Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.SetArraySlice2D``1(``0[,]`1,Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},``0[,]`1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.SignDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.SinDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.SinhDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.SqrtDynamic``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.TanDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.TanhDynamic``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.OptimizedRanges.TruncateDynamic``1(``0)">

</member>
<member name="T:Microsoft.FSharp.Core.Operators.OptimizedRanges">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.defaultof``1">
<summary>
 Generate a defult value for any type. This is null for reference types, 
 For structs, this is struct value where all fields have the default value. 
 This function is unsafe in the sense that some F# values do not have proper <c>null</c> values.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.Unchecked">
<summary>
 This module contains the basic arithmetic operations with overflow checks.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators">

</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc2`3.Invoke(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc2`3.Adapt(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}})">

</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc2`3..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FastFunc2`3">
<summary>
 The .NET type used to represent F# function values that accept
 two iterated (curried) arguments without intervening execution.  This type should not
 typically used directly from either F# code or from other .NET languages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc3`4.Invoke(``0,``1,``2)">

</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc3`4.Adapt(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``3}}})">

</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc3`4..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FastFunc3`4">
<summary>
 The .NET type used to represent F# function values that accept
 three iterated (curried) arguments without intervening execution.  This type should not
 typically used directly from either F# code or from other .NET languages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc4`5.Invoke(``0,``1,``2,``3)">

</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc4`5.Adapt(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,Microsoft.FSharp.Core.FastFunc`2{``3,``4}}}})">

</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc4`5..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FastFunc4`5">
<summary>
 The .NET type used to represent F# function values that accept
 four iterated (curried) arguments without intervening execution.  This type should not
 typically used directly from either F# code or from other .NET languages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc5`6.Invoke(``0,``1,``2,``3,``4)">

</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc5`6..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FastFunc5`6">
<summary>
 The .NET type used to represent F# function values that accept
 five iterated (curried) arguments without intervening execution.  This type should not
 typically used directly from either F# code or from other .NET languages.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures">
<summary>
 An implementation module used to hold some private implementations of function
 value invocation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.bind``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},Microsoft.FSharp.Core.Option`1{``0})">
 <c>bind f inp</c> evaluates to <c>match inp with None -> None | Some x -> f x</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.Option`1{``0})">
 <c>exists p inp</c> evaluates to <c>match inp with None -> false | Some x -> p x</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.Option`1{``0})">
 <c>filter p inp</c> evaluates to <c>match inp with None -> None | Some x -> if p x then inp else None</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.fold_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Core.Option`1{``1})">
 <c>fold_left f s inp</c> evaluates to <c>match inp with None -> s | Some x -> f s x</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.fold_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Core.Option`1{``0},``1)">
 <c>fold_right f inp s</c> evaluates to "match inp with None -> s | Some x -> f x s"
</member>
<member name="M:Microsoft.FSharp.Core.Option.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.Option`1{``0})">
 <c>forall p inp" evaluates to "match inp with None -> true | Some x -> p x</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.get``1(Microsoft.FSharp.Core.Option`1{``0})">
<summary>
 Gets the value associated with the option.  If the option is None then
 raises <c>Invalid_argument "Option.get"</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.is_none``1(Microsoft.FSharp.Core.Option`1{``0})">
<summary>
 Returns true if the option is None
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.is_some``1(Microsoft.FSharp.Core.Option`1{``0})">
<summary>
 Returns true if the option is not None
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Option`1{``0})">
 <c>iter f inp</c> executes <c>match inp with None -> () | Some x -> f x</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.length``1(Microsoft.FSharp.Core.Option`1{``0})">
 <c>length inp</c> evaluates to <c>match inp with None -> 0 | Some _ -> 1</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Core.Option`1{``0})">
 <c>map f inp</c> evaluates to <c>match inp with None -> None | Some x -> Some (f x)</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.partition``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.Option`1{``0})">
 <c>partition p inp</c> evaluates to 
 <c>match inp with None -> None,None | Some x -> if p x then inp,None else None,inp</c>
</member>
<member name="M:Microsoft.FSharp.Core.Option.to_array``1(Microsoft.FSharp.Core.Option`1{``0})">
<summary>
 Convert the option to an array of length 0 or 1
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.to_list``1(Microsoft.FSharp.Core.Option`1{``0})">
<summary>
 Convert the option to a list of length 0 or 1
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Option">
<summary>
 Basic operations on options.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.any_to_layout``1(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.any_to_string``1(``0)">
<summary>
 Convert any value to a string using a standard formatter
 Data is typically formatted in a structured format, e.g.
 lists are formatted using the "[1;2]" notation.
 The details of the format are not specified and may change
 from version to version and according to the flags given
 to the F# compiler.  The format is intended to be human-readable,
 not machine readable.  If alternative generic formats are required
 you should develop your own formatter, using the code in the
 implementation of this file as a starting point.

 Data from other .NET languages is formatted using a virtual
 call to <c>Object.ToString()</c> on the boxed version of the input.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Pervasives.async">
<summary>
 Build an aysnchronous workflow using computation expression syntax
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.dict``2(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Builds a lookup table from a sequence of key/value pairs. The key objects are indexed using generic hashing and equality.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.eprintf``1(Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to <c>stderr</c> using the given format
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.eprintfn``1(Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to <c>stderr</c> using the given format, and add a newline
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.failwithf``2(Microsoft.FSharp.Text.Format`4{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
<summary>
 Print to a string buffer and raise an exception with the given
 result.   Helper printers must return strings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.fprintf``1(System.IO.TextWriter,Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a file using the given format
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.fprintfn``1(System.IO.TextWriter,Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a file using the given format, and add a newline
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.layout_as_string``1(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.layout_to_string(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,Microsoft.FSharp.Text.StructuredFormat.Layout)">

</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.op_Splice``1(Microsoft.FSharp.Quotations.Expr`1{``0})">
<summary>
 Special prefix operator for splicing typed expressions into quotation holes
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.op_SpliceUntyped``1(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Special prefix operator for splicing untyped expressions into quotation holes
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.output_any``1(System.IO.TextWriter,``0)">
<summary>
 Ouput any value to a channel using the same set of formatting rules
 as <c>any_to_string</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.output_layout(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,System.IO.TextWriter,Microsoft.FSharp.Text.StructuredFormat.Layout)">

</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.prerr_any``1(``0)">
<summary>
 Print any value to <c>stderr</c> using <c>any_to_string</c>. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.print_any``1(``0)">
<summary>
 Print any value to <c>stdin</c> using <c>any_to_string</c>. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.printf``1(Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to <c>stdout</c> using the given format
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.printfn``1(Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to <c>stdout</c> using the given format, and add a newline
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.seq``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Builds a sequence using sequence expression syntax
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.set``1(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Builds a set from a sequence of objects. The key objects are indexed using generic comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.sprintf``1(Microsoft.FSharp.Text.Format`4{``0,Microsoft.FSharp.Core.Unit,System.String,System.String})">
<summary>
 Print to a string using the given format
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.squash_layout(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,Microsoft.FSharp.Text.StructuredFormat.Layout)">

</member>
<member name="T:Microsoft.FSharp.Core.Pervasives">
<summary>
Pervasives: Additional bindings available at the top level 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.concat(System.String,System.Collections.Generic.IEnumerable`1{System.String})">
<summary>
 Return a new string made by concatenating the given strings
 with separator 'sep', i.e. 'a1 + sep + ... + sep + aN'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.exists(Microsoft.FSharp.Core.FastFunc`2{System.Char,System.Boolean},System.String)">
<summary>
Test if any character of the string satisfies the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.for_all(Microsoft.FSharp.Core.FastFunc`2{System.Char,System.Boolean},System.String)">
<summary>
Test if all characters in the string satisfy the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.iter(Microsoft.FSharp.Core.FastFunc`2{System.Char,Microsoft.FSharp.Core.Unit},System.String)">
<summary>
Apply the given function to each character in the string
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.map(Microsoft.FSharp.Core.FastFunc`2{System.Char,System.Char},System.String)">
<summary>
Build a new string whose characters are the results of applying the given function
to each of the characters of the input string.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.map_concat(Microsoft.FSharp.Core.FastFunc`2{System.Char,System.String},System.String)">
<summary>
Build a new string whose characters are the results of applying the given function
to each of the characters of the input string and concatenating the resulting
strings.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.String">
<summary>
 Compatibility module for ML string processing.  Richer string operations
 are available via the member functions on strings and other functionality in
  <a href="http://msdn2.microsoft.com/en-us/library/system.string.aspx">System.String</a> 
 and <a href="http://msdn2.microsoft.com/library/system.text.regularexpressions.aspx">System.Text.RegularExpressions</a> types.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.powi(Microsoft.FSharp.Math.BigInt,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_UnaryPlus(Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the given big integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_UnaryNegation(Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the negation of a big integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Subtraction(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the difference of big integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_RangeStep(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Generate a range of big integers, with a step
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Range(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Generate a range of big integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Multiply(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the product of big integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Modulus(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the modulus of big integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_LessThanOrEqual(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_LessThan(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_GreaterThanOrEqual(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_GreaterThan(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Equality(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Division(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the ratio of big integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Addition(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the sum of two big integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.hash(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="P:Microsoft.FSharp.Math.BigInt.Zero">
<summary>
 Get the big integer for zero
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigInt.One">
<summary>
 Get the big integer for one
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigInt.IsZero">

</member>
<member name="P:Microsoft.FSharp.Math.BigInt.IsSmall">

</member>
<member name="P:Microsoft.FSharp.Math.BigInt.IsPositive">

</member>
<member name="P:Microsoft.FSharp.Math.BigInt.IsOne">

</member>
<member name="P:Microsoft.FSharp.Math.BigInt.IsNegative">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.ToString">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.ToInt64(Microsoft.FSharp.Math.BigInt)">
<summary>
 Convert a big integer to a 64-bit signed integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.ToInt32(Microsoft.FSharp.Math.BigInt)">
<summary>
 Convert a big integer to a 32-bit signed integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.ToDouble(Microsoft.FSharp.Math.BigInt)">
<summary>
 Convert a big integer to a floating point number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.Sign(Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the sign of a big integer: 0, +1 or -1
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.Pow(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Return n^m for two big integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.Parse(System.String)">
<summary>
 Parse a big integer from a string format
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.GetHashCode">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.GCD(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the greatest common divisor of two big integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.FromInt64(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.FromInt32(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.Factorial(Microsoft.FSharp.Math.BigInt)">
<summary>
 Compute the factorial function as a big integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.DivMod(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">
<summary>
 Compute the ratio and remainder of two big integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.Abs(Microsoft.FSharp.Math.BigInt)">
<summary>
 Compute the absolute value of a big integer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt..ctor(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt..ctor(System.Int64)">

</member>
<member name="T:Microsoft.FSharp.Math.BigInt">
<summary>
 The type of arbitrary-sized integers
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.BigNat">
<summary>
 Abstract internal type
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_UnaryPlus(Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the given rational number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_UnaryNegation(Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the negation of a rational number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Subtraction(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the difference of two rational numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_RangeStep(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 Return a range of rational numbers, with the given increment
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Range(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 Return a range of rational numbers, with increment 1
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Multiply(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the product of two rational numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_LessThanOrEqual(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_LessThan(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_GreaterThanOrEqual(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_GreaterThan(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Equality(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 This operator is for use from other .NET languages
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Division(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the ratio of two rational numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Addition(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the sum of two rational numbers
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigNum.Zero">
<summary>
 Get zero as a rational number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigNum.One">
<summary>
 Get one as a rational number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigNum.Numerator">
<summary>
 Return the denominator of the normalized rational number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigNum.IsPositive">
<summary>
 Return a boolean indicating if this rational number is strictly positive
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigNum.IsNegative">
<summary>
 Return a boolean indicating if this rational number is strictly negative
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.BigNum.Denominator">
<summary>
 Return the denominator of the normalized rational number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.ToString">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.ToInt32(Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the result of converting the given rational number to an integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.ToDouble(Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the result of converting the given rational number to a floating point number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.ToBigInt(Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the result of converting the given rational number to a big integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.Sign(Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the sign of a rational number; 0, +1 or -1
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.PowN(Microsoft.FSharp.Math.BigNum,System.Int32)">
<summary>
 Return the result of raising the given rational number to the given power
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.Parse(System.String)">
<summary>
 Return the result of converting the string to a rational number 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.GetHashCode">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.FromInt(System.Int32)">
<summary>
 Return the result of converting the given integer to a rational number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.FromBigInt(Microsoft.FSharp.Math.BigInt)">
<summary>
 Return the result of converting the given big integer to a rational number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.Abs(Microsoft.FSharp.Math.BigNum)">
<summary>
 Return the absolute value of a rational number 
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.BigNum">
<summary>
 The type of arbitrary-sized rational numbers
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.BigRational">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.IsZero(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.add(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.bits(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.compare(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.div(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.divmod(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.equal(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.factorial(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.get_small(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.gt(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.gte(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.hash(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.hcf(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.isOne(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.isZero(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.is_small(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.lt(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.lte(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.max(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.min(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.mul(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.of_int64(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.of_string(System.String)">

</member>
<member name="P:Microsoft.FSharp.Math.BigNatModule.one">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.pow(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.powi(Microsoft.FSharp.Math.BigNat,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.rem(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.scale(System.Int32,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.sub(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.to_float(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.to_int(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.to_int64(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.to_string(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="P:Microsoft.FSharp.Math.BigNatModule.two">

</member>
<member name="P:Microsoft.FSharp.Math.BigNatModule.zero">

</member>
<member name="T:Microsoft.FSharp.Math.BigNatModule">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.add``1(Microsoft.FSharp.Core.nativeptr`1{``0},System.Int32)">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.get``1(Microsoft.FSharp.Core.nativeptr`1{``0},System.Int32)">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.of_array``1(``0[]`1,System.Int32)">
<summary>
 Get the address of an element of a pinned array
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.of_array2``1(``0[,]`1,System.Int32,System.Int32)">
<summary>
 Get the address of an element of a pinned 2-dimensional array
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.of_nativeint``1(System.IntPtr)">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.read``1(Microsoft.FSharp.Core.nativeptr`1{``0})">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.set``1(Microsoft.FSharp.Core.nativeptr`1{``0},System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.to_nativeint``1(Microsoft.FSharp.Core.nativeptr`1{``0})">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.write``1(Microsoft.FSharp.Core.nativeptr`1{``0},``0)">

</member>
<member name="T:Microsoft.FSharp.NativeInterop.NativePtr">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.blit``1(``0[]`1,System.Int32,``0[]`1,System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.copy``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.create``1(System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.fold_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,``1[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.fold_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},``0[]`1,``1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.get``1(``0[]`1,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.length``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.make``1(System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.of_list``1(Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.permute``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.Int32},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.set``1(``0[]`1,System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.sub``1(``0[]`1,System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.to_list``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.zero_create``1(System.Int32)">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.Array">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Helpers.invalid_arg2``1(System.String,System.String)">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.Helpers">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.append``1(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.concat``1(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Collections.List`1{``0}})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.find``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.length``1(Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.map2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.nonempty``1(Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.of_array``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.partition``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.rev``1(Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.stable_sort``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.to_array``1(Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.tryfind``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.unzip``2(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.unzip3``3(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`3{``0,``1,``2}})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.zip``2(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.zip3``3(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1},Microsoft.FSharp.Collections.List`1{``2})">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.List">

</member>
<member name="P:Microsoft.FSharp.Quotations.Expr.Type">
<summary>
 Returns type of an expression
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.Expr.CustomAttributes">
<summary>
 Returns the custom attributes of an expression
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.WhileLoop(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents a while loop
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.VarSet(Microsoft.FSharp.Quotations.Var,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents setting a mutable variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Var(Microsoft.FSharp.Quotations.Var)">
<summary>
 Build an expression that represents a variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Value(System.Object,System.Type)">
<summary>
 Build an expression that represents a constant value of a particular type
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Value``1(``0)">
<summary>
 Build an expression that represents a constant value 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.UnionCaseTest(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Reflection.UnionCaseInfo)">
<summary>
 Build an expression that represents a test of a value is of a particular union case
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.TypeTest(Microsoft.FSharp.Quotations.Expr,System.Type)">
<summary>
 Build an expression that represents a type test
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.TupleGet(Microsoft.FSharp.Quotations.Expr,System.Int32)">
<summary>
 Build an expression that represents getting a field of a tuple
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.TryWith(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Var,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Var,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents a try/with construct for exception filtering and catching 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.TryGetReflectedDefinition(System.Reflection.MethodBase)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.TryFinally(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents a try/finally construct 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Substitute(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Quotations.Var,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Quotations.Expr}})">
<summary>
 Substitute through the given expression using the given functions
 to map variables to new values.  The functions must give consistent results
 at each application.  Variable renaming may occur on the target expression
 if variable capture occurs.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Sequential(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents the sequential execution of one expression followed by another
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.RegisterReflectedDefinitions(System.Reflection.Assembly,System.String,System.Byte[]`1)">
<summary>
 Permit interactive environments such as F# Interactive
 to explicitly register new pickled resources that represent persisted 
 top level definitions. The string indicates a unique name for the resources
 being added. The format for the bytes is the encoding generated by the F# compiler.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Quote(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents a nested quotation literal
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.PropSet(Microsoft.FSharp.Quotations.Expr,System.Reflection.PropertyInfo,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr}})">
<summary>
 Build an expression that represents writing to a property of an object
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.PropSet(System.Reflection.PropertyInfo,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr}})">
<summary>
 Build an expression that represents writing to a static property 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.PropGet(Microsoft.FSharp.Quotations.Expr,System.Reflection.PropertyInfo,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr}})">
<summary>
 Build an expression that represents reading a property of an object
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.PropGet(System.Reflection.PropertyInfo,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr}})">
<summary>
 Build an expression that represents reading a static property 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.NewUnionCase(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build an expression that represents the creation of a union case value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.NewTuple(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build an expression that represents the creation of an F# tuple value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.NewRecord(System.Type,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build record-construction expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.NewObject(System.Reflection.ConstructorInfo,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build an expression that represents the invocation of an object constructor
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.NewDelegate(System.Type,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Var},Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents the creation of a delegate value for the given type
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.NewArray(System.Type,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build an expression that represents the creation of an array value initialized with the given elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.LetRec(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{Microsoft.FSharp.Quotations.Var,Microsoft.FSharp.Quotations.Expr}},Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build recursives expressions associated with 'let rec' constructs
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Let(Microsoft.FSharp.Quotations.Var,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build expressions associated with 'let' constructs
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Lambda(Microsoft.FSharp.Quotations.Var,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents the constrution of an F# function value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.IfThenElse(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build 'if ... then ... else' expressions    
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.GlobalVar``1(System.String)">
<summary>
 Fetch or create a new variable with the given name and type from a global pool of shared variables
 indexed by name and type. The type is given by the expicit or inferred type parameter
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.GetFreeVars">
<summary>
 Get the free expression variables of an expression as a list
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.ForIntegerRangeLoop(Microsoft.FSharp.Quotations.Var,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.FieldSet(System.Reflection.FieldInfo,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents writing to a static field 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.FieldSet(Microsoft.FSharp.Quotations.Expr,System.Reflection.FieldInfo,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents writing to a field of an object
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.FieldGet(System.Reflection.FieldInfo)">
<summary>
 Build an expression that represents the access of a static field 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.FieldGet(Microsoft.FSharp.Quotations.Expr,System.Reflection.FieldInfo)">
<summary>
 Build an expression that represents the access of a field of an object
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Deserialize(System.Type,Microsoft.FSharp.Collections.List`1{System.Type},Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr},System.Byte[]`1)">
<summary>
 This function is called automatically when quotation syntax (&lt;@ @&gt;) and related typed-expression
 quotations are used. The bytes are a pickled binary representation of an unlinked form of the qutoed expression,
 and the System.Type argument is any type in the assembly where the quoted
 expression occurs, i.e. it helps scope the interpretation of the cross-assembly
 references in the bytes.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.DefaultValue(System.Type)">
<summary>
 Build an expression that represents the invocation of a default object constructor
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Coerce(Microsoft.FSharp.Quotations.Expr,System.Type)">
<summary>
 Build an expression that represents the coercion of an expression to a type
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Cast``1(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Return a new typed expression given an underlying runtime-typed expression.
 A type annotation is usually required to use this function, and 
 using an incorrect type annotation may result in a later runtime exception.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Call(System.Reflection.MethodInfo,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build an expression that represents a call to an static method or module-bound function
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Call(Microsoft.FSharp.Quotations.Expr,System.Reflection.MethodInfo,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build an expression that represents a call to an instance method associated with an object
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Applications(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr}})">
<summary>
 Build an expression that represents the application of a first class funciton value to multiple arguments
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Application(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents the application of a first class funciton value to a single argument
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.AddressSet(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents setting the value held at a particular address
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.AddressOf(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build an expression that represents getting the address of a value
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.Expr">
<summary>
 Quoted expressions annotated with System.Type values. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.Expr`1.Raw">

</member>
<member name="T:Microsoft.FSharp.Quotations.Expr`1">
<summary>
 Type-carrying quoted expressions.  Expressions are generated either
 by quotations in source text or programatically
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.Var.Type">
<summary>
 The type associated with the variable
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.Var.Name">
<summary>
 The declared name of the variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Var.Global(System.String,System.Type)">
<summary>
 Fetch or create a new variable with the given name and type from a global pool of shared variables
 indexed by name and type
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Var..ctor(System.String,System.Type,Microsoft.FSharp.Core.Option`1{System.Boolean})">
<summary>
 Create a new variable with the given name, type and mutability
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.Var">
<summary>
 Information at the binding site of a variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|AndAlso|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions of the form <c>a &amp;&amp; b</c> 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Applications|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent the application of a (possibly curried or tupled) first class function value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Bool|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant boolean expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Byte|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant byte expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Char|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant unicode character expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Double|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant 64-bit floating point number expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Int16|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant int16 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Int32|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant int32 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Int64|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant int64 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Lambdas|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent a (possibly curried or tupled) first class function value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|MethodWithReflectedDefinition|_|(System.Reflection.MethodBase)">
<summary>
 An active pattern to recognize methods that have an associated ReflectedDefinition
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|OrElse|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions of the form <c>a || b</c> 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|PropertyGetterWithReflectedDefinition|_|(System.Reflection.PropertyInfo)">
<summary>
 An active pattern to recognize property getters or values in modules that have an associated ReflectedDefinition
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|PropertySetterWithReflectedDefinition|_|(System.Reflection.PropertyInfo)">
<summary>
 An active pattern to recognize property setters that have an associated ReflectedDefinition
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|SByte|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant signed byte expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Single|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant 32-bit floating point number expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|SpecificCall|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 A parameterized active pattern to recognize calls to a specified function or method
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|String|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant string expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|UInt16|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant unsigned int16 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|UInt32|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant unsigned int32 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|UInt64|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize constant unsigned int64 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatterns.|Unit|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize <c>()</c> constant expressions
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.DerivedPatterns">

</member>
<member name="M:Microsoft.FSharp.Quotations.ExprShape.RebuildShapeCombination(System.Object,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Re-build combination expressions. The first parameter should be an object
 returned by the <c>ShapeCombination</c> case of the active pattern in this module.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.ExprShape.|ShapeVar|ShapeLambda|ShapeCombination|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern that performs a complete decomposition viewing the expression tree as a binding structure
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.ExprShape">
<summary>
 Active patterns for traversing, visiting, rebuilding and tranforming expressions in a generic way
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|AddressOf|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent getting the address of a value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|AddressSet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent setting the value held at an address 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Application|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent applications of first class function values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Call|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent calls to static and instance methods, and functions defined in modules
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Coerce|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent coercions from one type to another
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|DefaultValue|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent invocations of a default constructor of a struct
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|FieldGet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent getting a static or instance field 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|FieldSet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent setting a static or instance field 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|ForIntegerRangeLoop|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent loops over integer ranges
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|IfThenElse|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent conditionals
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Lambda|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent first class function values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|LetRec|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent recursive let bindings of one or more variables
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Let|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent let bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|NewArray|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent the construction of arrays 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|NewDelegate|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent construction of delegate values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|NewObject|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent invocation of object constructors
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|NewRecord|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent construction of record values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|NewTuple|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent construction of tuple values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|NewUnionCase|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent construction of particular union case values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|PropGet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent the read of a static or instance property, or a non-function value declared in a module
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|PropSet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent setting a static or instance property, or a non-function value declared in a module
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Quote|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent a nested quotation literal
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Sequential|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent sequential exeuction of one expression followed by another
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|TryFinally|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent a try/finally construct 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|TryWith|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent a try/with construct for exception filtering and catching 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|TupleGet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent getting a tuple field
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|TypeTest|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent a dynamic type test
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|UnionCaseTest|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent a test if a value is of a particular union case
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Value|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent a constant value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|VarSet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent setting a mutable variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|Var|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent a variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Patterns.|WhileLoop|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 An active pattern to recognize expressions that represent while loops 
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.Patterns">

</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.MakeTupleType(System.Type[]`1)">
<summary>
 Return a <c>System.Type</c> representing an F# tuple type with the given element types
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.MakeFunctionType(System.Type,System.Type)">
<summary>
 Return a <c>System.Type</c> representing the F# function type with the given domain and range
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsUnion(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Return true if the <c>typ</c> is a representation of an F# union type or the runtime type of a value of that type
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsTuple(System.Type)">
<summary>
 Return true if the <c>typ</c> is a representation of an F# tuple type 
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsRecord(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Return true if the <c>typ</c> is a representation of an F# record type 
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsModule(System.Type)">
<summary>
 Return true if the <c>typ</c> is a <c>System.Type</c> value corresponding to the compiled form of an F# module 
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsFunction(System.Type)">
<summary>
 Return true if the <c>typ</c> is a representation of an F# function type or the runtime type of a closure implementing an F# type
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetUnionCases(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Get the cases of a union type.

 Assumes the given type is a union type. If not, ArgumentException is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetTupleElements(System.Type)">
<summary>
 Get the tuple elements from the representation of an F# tuple type  
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetRecordFields(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Read all the fields from a record value, in declaration order

 Assumes the given input is a record value. If not, ArgumentException is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetFunctionElements(System.Type)">
<summary>
 Get the domain and range types from an F# function type  or from the runtime type of a closure implementing an F# type
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.FSharpType">

</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PrecomputeUnionTagReader(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Precompute a function for reading an integer representing the case tag of a union type.

 Assumes the given type is a union type. 
 If not, ArgumentException is raised during pre-computation.

 Using the computed function is more efficient than calling GetUnionCase
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PrecomputeUnionTagMemberInfo(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Precompute a property or static method for reading an integer representing the case tag of a union type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PrecomputeUnionReader(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Precompute a function for reading all the fields for a particular discriminator case of a union type

 Using the computed function will typically be faster than executing a corresponding call to GetFields
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PrecomputeUnionConstructorInfo(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 A method that constructs objects of the given case
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PrecomputeUnionConstructor(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Precompute a function for constructing a discriminated union value for a particular union case. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PrecomputeTupleReader(System.Type)">
<summary>
 Precompute a function for reading the values of a particular tuple type

 Assumes the given type is a TupleType.
 If not, ArgumentException is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PrecomputeTuplePropertyInfo(System.Type,System.Int32)">
<summary>
 Get information that indicates how to read a field of a tuple
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PrecomputeTupleConstructorInfo(System.Type)">
<summary>
 Get a method that constructs objects of the given tuple type. 
 For small tuples, no additional typoe will be returned.
 
 For large tuples, an additional type is returned indicating that
 a nested encoding has been used for the tuple type. In this case
 the suffix portion of the tuple type has the given type and an
 object of this type must be created and passed as the last argument 
 to the ConstructorInfo. A recursive call to PrecomputeTupleConstructorInfo 
 can be used to determine the constructor for that the suffix type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PrecomputeTupleConstructor(System.Type)">
<summary>
 Precompute a function for reading the values of a particular tuple type

 Assumes the given type is a TupleType.
 If not, ArgumentException is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PrecomputeRecordReader(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Precompute a function for reading all the fields from a record. The fields are returned in the
 same order as the fields reported by a call to Microsoft.FSharp.Reflection.Type.GetInfo for
 this type.

 Assumes the given type is a RecordType. 
 If not, ArgumentException is raised during pre-computation.

 Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PrecomputeRecordFieldReader(System.Reflection.PropertyInfo)">
<summary>
 Precompute a function for reading a particular field from a record.
 Assumes the given type is a RecordType with a field of the given name. 
 If not, ArgumentException is raised during pre-computation.

 Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PrecomputeRecordConstructorInfo(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Get a ConstructorInfo for a record type
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PrecomputeRecordConstructor(System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Precompute a function for constructing a record value. 

 Assumes the given type is a RecordType.
 If not, ArgumentException is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeUnion(Microsoft.FSharp.Reflection.UnionCaseInfo,System.Object[]`1,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Create a union case value
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeTuple(System.Object[]`1,System.Type)">

</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeRecord(System.Type,System.Object[]`1,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Create an instance of a record type

 Assumes the given input is a record type. If not, ArgumentException is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeFunction(System.Type,Microsoft.FSharp.Core.FastFunc`2{System.Object,System.Object})">

</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetUnionFields(System.Object,System.Type,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Identify the union case and its fields for an object

 Assumes the given input is a union case value. If not, ArgumentException is raised.

 If the type is not given, then the runtime type of the input object is used to identify the
 relevant union type. The type should always be given if the input object may be null. For example, 
 option values may be represented using the 'null'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetTupleFields(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetTupleField(System.Object,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetRecordFields(System.Object,Microsoft.FSharp.Core.Option`1{System.Reflection.BindingFlags})">
<summary>
 Read all the fields from a record value

 Assumes the given input is a record value. If not, ArgumentException is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetRecordField(System.Object,System.Reflection.PropertyInfo)">
<summary>
 Read a field from a record value

 Assumes the given input is a record value. If not, ArgumentException is raised.
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.FSharpValue">

</member>
<member name="P:Microsoft.FSharp.Reflection.ModuleDefinition.TypeDefinitions">
<summary>
 Fetch the list of public type definitions in the F# Module.
 Private types and type abbreviations are not returned.
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.ModuleDefinition.ModuleDefinitions">
<summary>
 Fetch the list of public nested module definitions in the F# Module.
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.ModuleDefinition.ConcreteValues">
<summary>
 Fetch the list of concrete values in the F# Module, i.e. those that 
 have a canonical corresponding construct in the compiled IL version of the F# code. Inlined
 values and private values optimized away during compilation are not returned.
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.ModuleDefinition.CompiledHandle">
<summary>
 A handle that represents the compiled form of the F# module.
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.ModuleDefinition">

</member>
<member name="P:Microsoft.FSharp.Reflection.TypeDefinition.TypeInfo">
<summary>
 Return the GetTypeInfoOfType decomposition of a generic instance of the type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.TypeDefinition.CompiledHandle">
<summary>
 A handle that represents the compiled form of the F# type definition.
 This can be used to access all the features of the type definition, e.g. the
 type parameters, properties and other members. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.TypeDefinition">

</member>
<member name="T:Microsoft.FSharp.Reflection.TypeInfo">
<summary>
Represents the one-level decomposition of an F# type according to the
various structural types of the F# language.  

 Note: Most attributes associated with a System.Type value can be accessed
 via regular .NET reflection. However, it is useful to be able to view some
 F# type definitions from the perspective of the F# language, in particular
 for record, tuple and discriminated-union definitions. Although these types
 are ultimately compiled as .NET types, the details of the encoding used is
 often irrelevant, and this type and other items in this API help hide the
 details of this encoding.

</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.Tag">
<summary>
 The integer tag for the case
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.Name">
<summary>
 The name of the case
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.DeclaringType">
<summary>
 The type in which the case occurs
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetFields">
<summary>
 The fields associated with the case, represented by PropertyInfo 
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.UnionCaseInfo">
<summary>
Represents a case of a discriminated union type
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.ValueDefinition.CompiledHandle">
<summary>
 A handle that represents the compiled form of the F# value
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.ValueDefinition">

</member>
<member name="T:Microsoft.FSharp.Reflection.ValueInfo">
<summary>
Represents the one-level decomposition of an F# value according to the
various structural types of the F# language.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Assembly.GetFSharpModules(System.Reflection.Assembly)">
<summary>
 Get an enumeration of handles to the F#-defined concrete 
 module definitions in an assembly.  Nested module definitions
 are not returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Assembly.GetFSharpTypeDefinitions(System.Reflection.Assembly)">
<summary>
 Get handles to the F#-defined concrete type definitions 
 in an assembly.  Type definitions nested inside modules
 are not returned, nor are type definitions hidden inside modules, 
 and nor are type abbreviations.
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.Assembly">

</member>
<member name="M:Microsoft.FSharp.Reflection.Type.GetInfo(System.Type)">
<summary>
 Get the TypeInfo for a System.Type
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Type.GetTypeOfReprType(System.Type)">
<summary>
 Throw away extraneous compiler-specific information from a runtime type to return a true F# type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Type.IsListType(System.Type)">
<summary>
 A convenience function
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Type.IsOptionType(System.Type)">
<summary>
 A convenience function
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Type.IsUnitType(System.Type)">
<summary>
 A convenience function
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.Type">

</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetInfo``1(``0)">
<summary>
 Get the reflective view of a value
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetRecordConstructor(System.Type)">
<summary>
 Precompute a function for constructing a record value. 

 Assumes the given type is a RecordType.
 If not, ArgumentException is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetRecordFieldReader(System.Type,System.String)">
<summary>
 Precompute a function for reading a particular field from a record.
 Assumes the given type is a RecordType with a field of the given name. 
 If not, ArgumentException is raised during pre-computation.

 Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetRecordReader(System.Type)">
<summary>
 Precompute a function for reading all the fields from a record. The fields are returned in the
 same order as the fields reported by a call to Microsoft.FSharp.Reflection.Type.GetInfo for
 this type.

 Assumes the given type is a RecordType. 
 If not, ArgumentException is raised during pre-computation.

 Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetSumConstructor(System.Type,System.Int32)">
<summary>
 Precompute a function for constructing a discriminated union value for a particular tag. 

 Assumes the given type is a union type where the tag is a legitimate tag for the type.
 If not, ArgumentException is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetSumRecordReader(System.Type,System.Int32)">
<summary>
 Precompute a function for reading all the fields for a particular discriminator tag of a union type

 Assumes the given type is a union type where the tag is a legitimate tag for the type.
 If not, ArgumentException is raised during pre-computation.

 Tags can be mapped to and from names using the functions returned by GetSumTagConverters

 Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetSumTagConverters(System.Type)">
<summary>
 Precompute a pair of functions for converting between integer discriminator tags
 the names of the discriminators for the given union type.

 Assumes the given type is a union type. 
 If not, ArgumentException is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetSumTagReader(System.Type)">
<summary>
 Precompute a function for reading an integer representing the discriminator tag of a union type.

 Assumes the given type is a union type. 
 If not, ArgumentException is raised during pre-computation.

 Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetTupleConstructor(System.Type)">
<summary>
 Precompute a function for reading the values of a particular tuple type

 Assumes the given type is a TupleType.
 If not, ArgumentException is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetTupleReader(System.Type)">
<summary>
 Precompute a function for reading the values of a particular tuple type

 Assumes the given type is a TupleType.
 If not, ArgumentException is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetType``1(``0)">
<summary>
 Get the reified F# type of the value.  This will often be less
 specific than obj.GetType().
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetTypeInfo``1(``0)">

</member>
<member name="T:Microsoft.FSharp.Reflection.Value">

</member>
<member name="P:Microsoft.FSharp.Text.Format`4.Value">

</member>
<member name="M:Microsoft.FSharp.Text.Format`4..ctor(System.String)">

</member>
<member name="T:Microsoft.FSharp.Text.Format`4">
<summary>
 Type of a formatting expression
     'a : function type generated by printf
     'b: type argument passed to %a formatters
     'c: value generated by the overall printf action (e.g. sprint generates a string)
     'd: value generated after post processing (e.g. failwithf generates a string internally then raises an exception)
     'e: tuple of values generated by scan or match
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Format`5..ctor(System.String)">

</member>
<member name="T:Microsoft.FSharp.Text.Format`5">

</member>
<member name="T:Microsoft.FSharp.Text.Printf.BuilderFormat`1">
<summary>
 Represents a statically-analyzed format associated with writing to a <c>System.Text.StringBuilder</c>. The type parameter indicates the
 arguments and return type of the format operation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf.BuilderFormat`2">
<summary>
 Represents a statically-analyzed format associated with writing to a <c>System.Text.StringBuilder</c>. The first type parameter indicates the
 arguments of the format operation and the last the overall return type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf.StringFormat`1">
<summary>
 Represents a statically-analyzed format when formatting builds a string. The type parameter indicates the
 arguments and return type of the format operation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf.StringFormat`2">
<summary>
 Represents a statically-analyzed format when formatting builds a string. The first type parameter indicates the
 arguments of the format operation and the last the overall return type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf.TextWriterFormat`1">
<summary>
 Represents a statically-analyzed format associated with writing to a <c>System.IO.TextWriter</c>. The type parameter indicates the
 arguments and return type of the format operation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf.TextWriterFormat`2">
<summary>
 Represents a statically-analyzed format associated with writing to a <c>System.IO.TextWriter</c>. The first type parameter indicates the
 arguments of the format operation and the last the overall return type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.bprintf``1(System.Text.StringBuilder,Microsoft.FSharp.Text.Format`4{``0,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a <c>System.Text.StringBuilder</c>
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.eprintf``1(Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Formatted printing to stderr
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.eprintfn``1(Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Formatted printing to stderr, adding a newline 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.failwithf``2(Microsoft.FSharp.Text.Format`4{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
<summary>
 Print to a string buffer and raise an exception with the given
 result. Helper printers must return strings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.fprintf``1(System.IO.TextWriter,Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a text writer or an OCaml-compatible channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.fprintfn``1(System.IO.TextWriter,Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a text writer or an OCaml-compatible channel, adding a newline
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.kbprintf``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},System.Text.StringBuilder,Microsoft.FSharp.Text.Format`4{``1,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,``0})">
<summary>
 bprintf, but call the given 'final' function to generate the result.
 See <c>kprintf</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.kfprintf``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},System.IO.TextWriter,Microsoft.FSharp.Text.Format`4{``1,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,``0})">
<summary>
 fprintf, but call the given 'final' function to generate the result.
 See <c>kprintf</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.kprintf``2(Microsoft.FSharp.Core.FastFunc`2{System.String,``0},Microsoft.FSharp.Text.Format`4{``1,Microsoft.FSharp.Core.Unit,System.String,``0})">
<summary>
 printf, but call the given 'final' function to generate the result.
 For example, these let the printing force a flush after all output has 
 been entered onto the channel, but not before. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.ksprintf``2(Microsoft.FSharp.Core.FastFunc`2{System.String,``0},Microsoft.FSharp.Text.Format`4{``1,Microsoft.FSharp.Core.Unit,System.String,``0})">
<summary>
 sprintf, but call the given 'final' function to generate the result.
 See <c>kprintf</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.ktwprintf``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},System.IO.TextWriter,Microsoft.FSharp.Text.Format`4{``1,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,``0})">
<summary>
 twprintf, but call the given 'final' function to generate the result.
 See <c>kprintf</c>.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.printf``1(Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Formatted printing to stdout
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.printfn``1(Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Formatted printing to stdout, adding a newline 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.sprintf``1(Microsoft.FSharp.Text.Format`4{``0,Microsoft.FSharp.Core.Unit,System.String,System.String})">
<summary>
 Print to a string via an internal string buffer and return 
 the result as a string.  Helper printers must return strings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.twprintf``1(System.IO.TextWriter,Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to any subtype of the .NET type System.IO.TextWriter
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.twprintfn``1(System.IO.TextWriter,Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to any subtype of the .NET type System.IO.TextWriter, and add a newline
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf">
 <summary> Extensible printf-style formatting for numbers and other datatypes
 </summary>
  <remarks>
  <p>Format specifications are strings with "%" markers indicating format 
   placeholders. Format placeholders consist of:</p>
  <pre>
    %[flags][width][.precision][type]
  </pre> 
  <p>where the type is interpreted as follows:</p>
  <pre>
     %b:         bool, formatted as "true" or "false"
     %s:         string, formatted as its unescaped contents
     %d, %i:     any basic integer type formatted as a decimal integer, signed if the basic integer type is signed.
     %u:         any basic integer type formatted as an unsigned decimal integer
     %x, %X, %o: any basic integer type formatted as an unsigned hexadecimal 
                 (a-f)/Hexadecimal (A-F)/Octal integer
 
     %e, %E, %f, %F, %g, %G: 
                 any basic floating point type (float,float32) formatted
                 using a C-style floating point format specifications, i.e
 
     %e, %E: Signed value having the form [-]d.dddde[sign]ddd where 
                 d is a single decimal digit, dddd is one or more decimal
                 digits, ddd is exactly three decimal digits, and sign 
                 is + or -
 
     %f:     Signed value having the form [-]dddd.dddd, where dddd is one
                 or more decimal digits. The number of digits before the 
                 decimal point depends on the magnitude of the number, and 
                 the number of digits after the decimal point depends on 
                 the requested precision.
 
     %g, %G: Signed value printed in f or e format, whichever is 
                 more compact for the given value and precision.
 
 
    %M:      System.Decimal value
 
    %O:      Any value, printed by boxing the object and using it's ToString method(s)
 
    %A:      Any value, printed by using Microsoft.FSharp.Text.StructuredFormat.Display.any_to_string with the default layout settings 
 
    %a:      A general format specifier, requires two arguments:
                 (1) a function which accepts two arguments:
                     (a) a context parameter of the appropriate type for the
                         given formatting function (e.g. an #System.IO.TextWriter)
                     (b) a value to print
                         and which either outputs or returns appropriate text.
 
                 (2) the particular value to print
 
 
    %t:      A general format specifier, requires one argument:
                 (1) a function which accepts a context parameter of the
                     appropriate type for the given formatting function (e.g. 
                     an #System.IO.TextWriter)and which either outputs or returns 
                     appropriate text.

  Basic integer types are:
     byte,sbyte,int16,uint16,int32,uint32,int64,uint64,nativeint,unativeint
  Basic floating point types are:
     float, float32

 
 The following format patterns are accepted but a warning is printed:

     %h(d|u|x|X|o)
     %l(d|u|x|X|o)

  The following format patterns are now deprecated:

     %Ld, %Li, %Lu, %Lx, %LX, %Lo: same, but an int64
     %nd, %ni, %nu, %nx, %nX, %no: same, but a nativeint
     %Ud, %Ui, %Uu, %Ux, %UX, %Uo: same, but an unsigned int32 (uint32)
     %ULd, %ULi, %ULu, %ULx, %ULX, %ULo: same, but an unsigned int64 (uint64)
     %Und, %Uni, %Unu, %Unx, %UnX, %Uno: same, but an unsigned nativeint (unativeint)
 </pre>
 <p>The optional width is an integer indicating the minimal width of the
    result. For instance, %6d prints an integer, prefixing it with spaces
    to fill at least 6 characters. If width is '*', then an extra integer
    argument is taken to specify the corresponding width.
 </p>
 <pre>
     any number
     '*': 
 </pre>
 <p>Valid flags are: </p>
 <pre>
     0: add zeros instead of spaces to make up the required width
     '-': left justify the result within the width specified
     '+': add a '+' character if the number is positive (to match a '-' sign 
          for negatives)
     ' ': add an extra space if the number is positive (to match a '-' 
              sign for negatives)
 </pre>
 <p>The printf '#' flag is invalid and a compile-time error will be reported if it is used.</p>
 </remarks>
 <examples>
 <pre>
   Printf.printf "Hello %s, %d = %d * %d" "World" 6 2 3;
   Printf.sprintf "Hello %s" "World";
   Printf.printf "Hello %a" output_string "World";
 </pre>
 </examples>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredFormat.FormatOptions.Default">

</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.FormatOptions">
<summary>
 A record of options to control structural formatting.
 For F# Interactive properties matching those of this value can be accessed via the 'fsi'
 value.
 
 Floating Point format given in the same format accepted by System.Double.ToString,
 e.g. f6 or g15.

 If ShowProperties is set the printing process will evaluate properties of the values being
 displayed.  This may cause additional computation.  

 The ShowIEnumerable is set the printing process will force the evalution of IEnumerable objects
 to a small, finite depth, as determined by the printing parameters.
 This may lead to additional computation being performed during printing.

 <example>
 From F# Interactive the default settings can be adjusted using, for example, 
 <pre>
   open Microsoft.FSharp.Compiler.Interactive.Settings;;
   setPrintWidth 120;;
 </pre>
 </example>
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredFormat.IEnvironment.MaxRows">
<summary>
 The maximum number of rows for which to generate layout for table-like 
 structures.  -1 if no maximum.
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredFormat.IEnvironment.MaxColumns">
<summary>
 The maximum number of elements for which to generate layout for 
 list-like structures, or columns in table-like 
 structures.  -1 if no maximum.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.IEnvironment.GetLayout(System.Object)">
<summary>
 Return to the layout-generation 
 environment to layout any otherwise uninterpreted object
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.IEnvironment">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.IFormattable.GetLayout(Microsoft.FSharp.Text.StructuredFormat.IEnvironment)">
<summary>
 Generate an object representing a structured formatting of the
 term.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.IFormattable">

</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.Joint">
<summary>
 Data representing joints in structured layouts of terms.  The representation
 of this data type is only for the consumption of formatting engines.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.Layout">
<summary>
 Data representing structured layouts of terms.  The representation
 of this data type is only for the consumption of formatting engines.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.joint">
<summary>
 Data representing joints in structured layouts of terms.  The representation
 of this data type is only for the consumption of formatting engines.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.layout">
<summary>
 Data representing structured layouts of terms.  The representation
 of this data type is only for the consumption of formatting engines.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.Display.any_to_layout``1(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,``0)">
<summary>
 Convert any value to a layout using the given formatting options.  The
 layout can then be processed using formatting display engines such as
 those in the LayoutOps module.  any_to_string and output_any are
 built using any_to_layout with default format options.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.Display.any_to_string``1(``0)">
<summary>
 Convert any value to a string using a standard formatter
 Data is typically formatted in a structured format, e.g.
 lists are formatted using the "[1;2]" notation.
 The details of the format are not specified and may change
 from version to version and according to the flags given
 to the F# compiler.  The format is intended to be human-readable,
 not machine readable.  If alternative generic formats are required
 you should develop your own formatter, using the code in the
 implementation of this file as a starting point.

 Data from other .NET languages is formatted using a virtual
 call to Object.ToString() on the boxed version of the input.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.Display.layout_as_string``1(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,``0)">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.Display.layout_to_string(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,Microsoft.FSharp.Text.StructuredFormat.Layout)">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.Display.output_any``1(System.IO.TextWriter,``0)">
<summary>
 Ouput any value to a channel using the same set of formatting rules
 as any_to_string
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.Display.output_layout(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,System.IO.TextWriter,Microsoft.FSharp.Text.StructuredFormat.Layout)">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.Display.squash_layout(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,Microsoft.FSharp.Text.StructuredFormat.Layout)">

</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.Display">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.aboveL(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Layout two vertically.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.aboveListL(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Layout list vertically.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.braceL(Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Wrap braces around layout.        
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.bracketL(Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Wrap round brackets around layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.commaListL(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Join layouts into a comma separated list.
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.emptyL">
<summary>
 The empty layout
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.isEmptyL(Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Is it the empty layout?
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.leftL(System.String)">
<summary>
 An string which is left  parenthesis (no space on the right).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.listL``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Text.StructuredFormat.Layout},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Layout like an F# list.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.objL(System.Object)">
<summary>
 An uninterpreted leaf, to be interpreted into a string
 by the layout engine. This allows leaf layouts for numbers, strings and
 other atoms to be customized according to culture.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_AtAt(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join broken with ident=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_AtAtMinus(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join broken with ident=1 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_AtAtMinusMinus(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join broken with ident=2 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_DollarDollar(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join, unbreakable. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_MinusMinus(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join, possible break with indent=1
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_MinusMinusMinus(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join, possible break with indent=2 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_PlusPlus(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join, possible break with indent=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.optionL``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Text.StructuredFormat.Layout},Microsoft.FSharp.Core.Option`1{``0})">
<summary>
 Layout like an F# option.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.rightL(System.String)">
<summary>
 An string which is right parenthesis (no space on it's left).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.semiListL(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Join layouts into a semi-colon separated list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.sepL(System.String)">
<summary>
 An string which requires no spaces either side.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.sepListL(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Join layouts into a list separated using the given layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.spaceListL(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Join layouts into a space separated list.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.squareBracketL(Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Wrap square brackets around layout.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.tagAttrL(System.String,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{System.String,System.String}},Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 See tagL
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.tupleL(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Form tuple of layouts.            
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.unfoldL``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Text.StructuredFormat.Layout},Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}}},``1,System.Int32)">
<summary>
 For limitting layout of list-like sequences (lists,arrays,etc).
 unfold a list of items using (project and z) making layout list via itemL.
 If reach maxLength (before exhausting) then truncate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.wordL(System.String)">
<summary>
 An string leaf 
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.LayoutOps">
<summary>
 A layout is a sequence of strings which have been joined together.
 The strings are classified as words, separators and left and right parenthesis.
 This classification determines where spaces are inserted.
 A joint is either unbreakable, breakable or broken.
 If a joint is broken the RHS layout occurs on the next line with optional indentation.
 A layout can be squashed to for given width which forces breaks as required.
</summary>
</member>
</members>
</doc>
