using System.Collections.Generic;
using System.IO;
using System.Xml;

namespace NHaml
{
    public class AttributeParser
    {
        public static Regex StartCodeRegex;
        public static Regex StartTextWithDoubleQuotesRegex;
        public static Regex StartTextWithSingleQuotesRegex;
        public static Regex StartTextWithOutQuotesRegex;
        public static Regex KeyValueSplitRegex;

        private readonly string attributes;
<<<<<<< HEAD:src/NHaml/AttributeParser.cs
        XmlReader reader;
=======

        private State? state;
        private string currentValue;
        private string currentKey;
        private bool isCurrentCode;
        private bool isSingleQuotes;
        private int index;
>>>>>>> Integrate MetaMarkup to provide model type inside of a template file.:src/NHaml/AttributeParser.cs

        private enum State
        {
            Code,
            Text,
            Key
        }

        // So at the moment, I'm leaning towards {foo="bar"} or {foo=bar} for
        // static attributes and {foo=#{bar}} for dynamic ones. Thoughts?
        public AttributeParser(string attributes)
        {
            this.attributes = attributes.TrimStart();
<<<<<<< HEAD:src/NHaml/AttributeParser.cs
=======
            Values = new List<KeyValuePair>();
        }

        public void Parse()
        {
            for (index = attributes.Length - 1; index > -1; )
            {
                var character = attributes[index];
                if (state == null)
                {
                    currentValue = null;
                    currentKey = null;
                    if (character == '}')
                    {
                        state = State.Code;
                        isCurrentCode = true;
                    }
                    else if (character != ' ' && character != '\t')
                    {
                        if (character == '"')
                        {
                            isSingleQuotes = false;
                        }
                        else if (character == '\'')
                        {
                            isSingleQuotes = true;
                        }
                        state = State.Text;
                        isCurrentCode = false;
                    }
                    index--;
                }
                else
                {
                    switch (state.Value)
                    {
                        case (State.Code):
                            {
                                ProcessCodeChar(character);
                                break;
                            }
                        case (State.Key):
                            {
                                ProcessKeyChar(character);
                                break;
                            }
                        case (State.Text):
                            {
                                ProcessTextChar(character);
                                break;
                            }
                    }
                }
            }
>>>>>>> Integrate MetaMarkup to provide model type inside of a template file.:src/NHaml/AttributeParser.cs
        }

        public Dictionary<string, string> Values { get; set; }

        public void Parse()
        {
<<<<<<< HEAD:src/NHaml/AttributeParser.cs
            Values = new Dictionary<string, string>();
            reader = XmlReader.Create(new StringReader(string.Format("<node {0}/>", attributes)));
            reader.MoveToContent();
            while (reader.MoveToNextAttribute())
=======
            var substring = attributes.Substring(0, index + 1);
            var group = StartCodeRegex.Match(substring).Groups["ToTrim"];
           
            if (group.Success)
>>>>>>> Integrate MetaMarkup to provide model type inside of a template file.:src/NHaml/AttributeParser.cs
            {
                Values.Add(reader.Name, reader.Value);
            }
        }

<<<<<<< HEAD:src/NHaml/AttributeParser.cs
=======
        public List<KeyValuePair> Values { get; set; }

        public class KeyValuePair
        {
            public string Key;
            public string Value;
            public bool IsCode;
        }
>>>>>>> Integrate MetaMarkup to provide model type inside of a template file.:src/NHaml/AttributeParser.cs
    }
}
